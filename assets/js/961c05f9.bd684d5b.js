"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[564],{5139:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=i(4848),r=i(8453);const s=i.p+"assets/images/anti_corruption_layer-588d621c6a7a7ce61c6427551edfba66.png",a={slug:"hexagonal-architecture-java-spring-boot-part-3",title:"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht",authors:"ricardo",tags:["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],date:new Date("2024-01-08T00:00:00.000Z")},d=void 0,l={permalink:"/hexagonal-architecture-java-spring-boot-part-3",source:"@site/blog/hexagonal-architecture/part3/part3.mdx",title:"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht",description:"banner",date:"2024-01-08T00:00:00.000Z",formattedDate:"8. Januar 2024",tags:[{label:"Domain-driven Design",permalink:"/tags/domain-driven-design"},{label:"Hexagonale Architektur",permalink:"/tags/hexagonale-architektur"},{label:"Softwarearchitektur",permalink:"/tags/softwarearchitektur"},{label:"Softwareentwicklung",permalink:"/tags/softwareentwicklung"}],readingTime:10.135,hasTruncateMarker:!0,authors:[{name:"Ricardo Schnur",title:"Software Developer @ Colenet GmbH",url:"https://github.com/ricardo-schnur",imageURL:"img/profile.png",key:"ricardo"}],frontMatter:{slug:"hexagonal-architecture-java-spring-boot-part-3",title:"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht",authors:"ricardo",tags:["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],date:"2024-01-08T00:00:00.000Z"},unlisted:!1,prevItem:{title:"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 4: Folgen einer \xc4nderung am Dom\xe4nenmodell und die Applikationsschicht",permalink:"/hexagonal-architecture-java-spring-boot-part-4"},nextItem:{title:"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 2: Modellierung, Kernlogik und In-Memory Cache",permalink:"/hexagonal-architecture-java-spring-boot-part-2"}},o={authorsImageUrls:[void 0]},c=[{value:"Tasks mittels eines dedizierten Modells serialisierbar machen",id:"tasks-mittels-eines-dedizierten-modells-serialisierbar-machen",level:2},{value:"Anlegen eines REST-Controllers",id:"anlegen-eines-rest-controllers",level:2},{value:"Datenintegrit\xe4t durch eine Antikorruptionsschicht",id:"datenintegrit\xe4t-durch-eine-antikorruptionsschicht",level:2},{value:"Ausblick",id:"ausblick",level:2}];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Head:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"banner",src:i(6549).A+"",width:"1028",height:"611"})}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Um zu verstehen, wie hexagonale Architektur die Art und Weise, Software zu entwickeln, ver\xe4ndert und was dabei\ndie Vorteile sind, f\xfchrt Ricardo uns Schritt f\xfcr Schritt durch die Entwicklung einer To-Do-Listen-Anwendung.\nIm 3. Teil wird nun \xfcber eine REST-Schnittstelle die Anwendung interaktiv nutzbar gemacht und die Datenintegrit\xe4t\ndurch eine Antikorruptionsschicht sichergestellt."}),"\n"]}),"\n","\n",(0,t.jsx)(a,{children:(0,t.jsx)("link",{rel:"canonical",href:"https://www.colenet.de/blog/development/hexagonale-architektur-in-der-praxis-teil-3-rest-schnittstelle-mit-antikorruptionsschicht/"})}),"\n","\n","\n",(0,t.jsxs)(n.p,{children:["Diese Artikel-Reihe ist der hexagonalen Architektur gewidmet: Wir m\xf6chten ihre Grundprinzipien verstehen und diese in\nder Praxis erleben. Wir werden uns anschauen, wie sich eine hexagonale Architektur in einer typischen Webanwendung\npraktisch realisieren l\xe4sst. Dazu werden wir Schritt f\xfcr Schritt eine kleine ",(0,t.jsx)(n.strong,{children:"To-do-Listen-Anwendung"})," entwickeln, die\nes\nerm\xf6glichen soll, Tasks anzulegen, angelegte Tasks anzuzeigen und Tasks als erledigt zu markieren. Die Anwendung wird\n\xfcber eine REST-Schnittstelle bedienbar sein und die Tasks werden konfigurierbar entweder In-Memory oder persistent in\neiner echten MongoDB verwaltet."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-1",children:"Im ersten Teil"})," dieser Serie haben wir\nein frisches Java/Spring-Boot-Projekt aufgesetzt und konfiguriert. Wir haben uns\n\xfcberlegt, wie wir uns die Architektur der Anwendung und ihre Umsetzung vorstellen und diese Vorstellung mittels ArchUnit\nin einem automatisierten Architekturtest festgehalten."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-2",children:"Im zweiten Teil"})," sind wir mit der\nModellierung der Dom\xe4ne, der Implementierung der Kernlogik und der Datenhaltung der\nAnwendung in die eigentliche Entwicklung gestartet."]}),"\n",(0,t.jsx)(n.p,{children:"Nun m\xf6chten wir unsere Anwendung auch interaktiv nutzbar machen und zu diesem Zweck eine REST-Schnittstelle\nbereitstellen.\nGenauer m\xf6chten wir"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["einen ",(0,t.jsx)(n.code,{children:"GET"}),"-Endpunkt ",(0,t.jsx)(n.code,{children:"/task"}),", der uns alle existierenden Tasks zur\xfcckliefert,"]}),"\n",(0,t.jsxs)(n.li,{children:["einen ",(0,t.jsx)(n.code,{children:"POST"}),"-Endpunkt ",(0,t.jsx)(n.code,{children:"/task"}),", der es uns erlaubt, einen neuen Task anzulegen und den angelegten Task zur\xfcckliefert,\nsowie"]}),"\n",(0,t.jsxs)(n.li,{children:["einen ",(0,t.jsx)(n.code,{children:"POST"}),"-Endpunkt ",(0,t.jsx)(n.code,{children:"/task/toggle-completion/{id}"}),", der es uns erlaubt, den Zustand eines existierenden\nTasks umzuschalten und den umgeschalteten Task zur\xfcckliefert."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Hierbei soll der ",(0,t.jsx)(n.code,{children:"POST"}),"-Endpunkt ",(0,t.jsx)(n.code,{children:"/task"})," mit einem Parameter ",(0,t.jsx)(n.code,{children:"description"})," aufgerufen werden k\xf6nnen.\nM\xf6gliche Requests sehen dann etwa folgenderma\xdfen aus:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET http://localhost:8080/tasks\nPOST http://localhost:8080/tasks?description=Some%20Task\nPOST http://localhost:8080/tasks/toggle-completion/69676cbb-430c-4be8-a3f2-f15cf9e976c3\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Au\xdferdem wollen wir nat\xfcrlich auch mit fehlerhaften Benutzereingaben (wie etwa leerer ",(0,t.jsx)(n.code,{children:"description"})," oder unbekannter\n",(0,t.jsx)(n.code,{children:"id"}),") umgehen k\xf6nnen und werden dazu eine sogenannte Antikorruptionsschicht zwischen unsere Kernlogik und den\nREST-Adapter schalten. In einem ersten Schritt wollen wir uns aber erst einmal wieder mit Datenmodellen befassen."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Ihr findet den aktuellen Stand des Projekts sowie die \xc4nderungen auch aus diesem Teil\nauf ",(0,t.jsx)(n.a,{href:"https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post3",children:"GitHub"}),"."]})}),"\n",(0,t.jsx)(n.h2,{id:"tasks-mittels-eines-dedizierten-modells-serialisierbar-machen",children:"Tasks mittels eines dedizierten Modells serialisierbar machen"}),"\n",(0,t.jsxs)(n.p,{children:["Als wir unser Dom\xe4nenobjekt ",(0,t.jsx)(n.code,{children:"Task"})," modelliert haben, haben wir uns bewusst ",(0,t.jsx)(n.em,{children:"nicht"})," mit technischen Belangen\nauseinandergesetzt, sondern uns komplett auf die Fachlichkeit fokussiert. Entsprechend ungeeignet ist dieses Modell\ndaher als Austauschformat. Das ist aber nicht weiter problematisch: Wir definieren uns nun ein\ndediziertes Transfermodell ",(0,t.jsx)(n.code,{children:"TaskDto"}),", das m\xf6glichst schlank und einfach (de-)serialisierbar sein soll, und\nkonvertieren dann nach Bedarf zwischen ",(0,t.jsx)(n.code,{children:"Task"})," und ",(0,t.jsx)(n.code,{children:"TaskDto"})," hin und her."]}),"\n",(0,t.jsxs)(n.p,{children:["Dieses Transfermodell ist ein technisches\nDetail unserer REST-Schnittstelle und wird daher auch Teil unseres ",(0,t.jsx)(n.strong,{children:"REST-Adapters"}),", den wir in diesem Abschnitt\nanlegen.\nDa nach unseren Architekturregeln keine andere Schicht und auch kein anderer Adapter auf diesen REST-Adapter\nzugreifen darf, ist hierdurch sichergestellt, dass wir das Transfermodell ",(0,t.jsx)(n.code,{children:"TaskDto"})," einzig lokal in diesem\nAdapter verwenden und es sich nicht durch den Rest unserer Codebasis verbreiten wird."]}),"\n",(0,t.jsx)(n.p,{children:"Die Implementierung ist denkbar einfach gehalten:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"package de.colenet.hexagonal.todo.list.adapter.rest.model;\n\npublic record TaskDto(String id, String description, String state, String completionTime) {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Statt eines Summentyps verwenden wir jetzt einen Produkttyp mit dem zus\xe4tzlichen Feld ",(0,t.jsx)(n.code,{children:"state"})," als Diskriminator.\nAu\xdferdem verwenden wir simple, serialisierbare Typen f\xfcr alle Eigenschaften. Hierdurch gehen uns nat\xfcrlich einige\nGarantien verloren, daf\xfcr erhalten wir eine flache, serialisierbare Struktur."]}),"\n",(0,t.jsxs)(n.p,{children:["Um mit dem neu erzeugten Modell ",(0,t.jsx)(n.code,{children:"TaskDto"})," arbeiten zu k\xf6nnen, brauchen wir noch eine M\xf6glichkeit einen ",(0,t.jsx)(n.code,{children:"Task"}),"\nin ein ",(0,t.jsx)(n.code,{children:"TaskDto"})," umzuwandeln. Dazu bauen wir uns einen Mapper mit einer entsprechenden Methode\n",(0,t.jsx)(n.code,{children:"TaskDto toDto(Task model)"}),". In dieser werden wir wieder ",(0,t.jsx)(n.em,{children:"Pattern Matching"})," verwenden mit der Konvention, unbenutzte\nParameter mit einem Unterstrich zu kennzeichnen:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'package de.colenet.hexagonal.todo.list.adapter.rest.mapper;\n\nimport ...; // Omitted for clarity\n\n@Component\npublic class RestApiMapper {\n\n  public TaskDto toDto(Task model) {\n    return new TaskDto(\n            model.id().toString(),\n            model.description(),\n            switch (model) {\n              case OpenTask __ -> "open";\n              case CompletedTask __ -> "completed";\n            },\n            switch (model) {\n              case OpenTask __ -> null;\n              case CompletedTask t -> t.completionTime().toString();\n            }\n    );\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"anlegen-eines-rest-controllers",children:"Anlegen eines REST-Controllers"}),"\n",(0,t.jsx)(n.p,{children:"Nachdem wir uns \xfcber die Datenstrukturen im Klaren sind, k\xf6nnen wir jetzt zur Implementierung der Endpunkte \xfcbergehen.\nDazu starten wir mit einem Controller, der Zugriff auf unseren Service sowie auf den neu angelegten Mapper haben wird:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"package de.colenet.hexagonal.todo.list.adapter.rest.controller;\n\nimport ...; // Omitted for clarity\n\n@RestController\nclass RestApiController {\n\n  private final RestApiMapper restApiMapper;\n  private final TaskService taskService;\n\n  RestApiController(RestApiMapper restApiMapper, TaskService taskService) {\n    this.restApiMapper = restApiMapper;\n    this.taskService = taskService;\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Wir wollen uns in einem ersten Schritt um den ",(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"GET"}),"-Endpunkt"]})," k\xfcmmern, der alle existierenden Tasks zur\xfcckliefern\nsoll.\nDazu rufen wir die entsprechende Methode in unserem Service auf, wandeln die Resultate mittels unseres Mappers in\nDtos um und verpacken das Ergebnis schlie\xdflich in einer ",(0,t.jsx)(n.code,{children:"ResponseEntity"}),". Die Methode annotieren wir schlie\xdflich\nnoch mit ",(0,t.jsx)(n.code,{children:"@GetMapping"}),", alles Weitere erledigt Spring dann automatisch im Hintergrund."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@GetMapping(value = "/tasks", produces = MediaType.APPLICATION_JSON_VALUE)\nResponseEntity<List<TaskDto>> getAllTasks() {\n  return createOkResponse(taskService.getAllTasks().stream().map(restApiMapper::toDto).toList());\n}\n\nprivate static <T> ResponseEntity<T> createOkResponse(T value) {\n  return new ResponseEntity<>(value, HttpStatus.OK);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["F\xfcr den ",(0,t.jsx)(n.strong,{children:"Endpunkt zum Anlegen eines neuen Tasks"})," gehen wir v\xf6llig analog vor, nur dass wir hier noch einen Parameter\nzu\nber\xfccksichtigen haben:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@PostMapping(value = "/tasks", produces = MediaType.APPLICATION_JSON_VALUE)\nResponseEntity<?> createTask(@RequestParam String description) {\n  return createOkResponse(restApiMapper.toDto(taskService.createTask(description)));\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Schlie\xdflich fehlt uns noch der ",(0,t.jsx)(n.strong,{children:"Endpunkt zum Umschalten des Zustands eines existierenden Tasks."})," Auch hier verfolgen\nwir wieder das Schema, die entsprechende Logik im Service aufzurufen und das Resultat umzuwandeln, m\xfcssen jedoch\nauch beachten, dass wir diesmal erst unseren ",(0,t.jsx)(n.code,{children:"id"})," Parameter von ",(0,t.jsx)(n.code,{children:"String"})," zu ",(0,t.jsx)(n.code,{children:"UUID"})," konvertieren m\xfcssen und wir\nau\xdferdem mit der Situation, dass es keinen Task mit der angegebenen ID gibt, umgehen k\xf6nnen m\xfcssen. In diesem Fall\nwerden wir schlicht mit dem Status ",(0,t.jsx)(n.code,{children:"400 Bad Request"})," antworten."]}),"\n",(0,t.jsx)(n.p,{children:"Damit gestaltet sich die Methode folgenderma\xdfen:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@PostMapping(value = "/tasks/toggle-completion/{id}", produces = MediaType.APPLICATION_JSON_VALUE)\nResponseEntity<?> toggleCompletionState(@PathVariable String id) {\n  return taskService\n          .toggleCompletionState(UUID.fromString(id))\n          .map(restApiMapper::toDto)\n          .map(RestApiController::createOkResponse)\n          .orElseGet(RestApiController::createBadRequestResponse);\n}\n\nprivate static <T> ResponseEntity<T> createBadRequestResponse() {\n  return new ResponseEntity<>(HttpStatus.BAD_REQUEST);\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Hiermit haben wir nun eine voll funktionsf\xe4hige Anwendung!"}),"\n",(0,t.jsxs)(n.p,{children:["Im ",(0,t.jsx)(n.a,{href:"https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post3",children:"GitHub Repository"})," findet ihr\nau\xdferdem noch\n",(0,t.jsx)(n.strong,{children:"Unit- und Integrationstests"})," f\xfcr unseren neuen Controller (",(0,t.jsx)(n.code,{children:"RestApiControllerTest"}),"\nund ",(0,t.jsx)(n.code,{children:"RestApiControllerIntegrationTest"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Zus\xe4tzlich ist es uns jetzt auch m\xf6glich, ",(0,t.jsx)(n.strong,{children:"End-To-End-Tests"}),", die einen vollst\xe4ndigen Anwendungskontext hochfahren,\neine\nFolge von REST-Requests absetzen und von der Anwendung entsprechende Antworten erwarten, zu schreiben. Diese m\xf6chte\nich an dieser Stelle kurz demonstrieren, da sie auch demonstrieren, wie unsere Anwendung zu verwenden ist:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\nclass HexagonalToDoListApplicationEndToEndTests {\n\n  @Autowired\n  private TestRestTemplate restTemplate;\n\n  @Test\n  void returnsEmptyListIfNoTasksHaveBeenCreated() {\n    var result = getAllTasks();\n\n    assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);\n    assertThat(result.getBody()).isEmpty();\n  }\n\n  @Test\n  void creatingTasksIsPossibleAndCreatedTasksAreReturnedFromGetAll() {\n    List<String> descriptions = List.of("Some description", "Some other description");\n\n    descriptions.forEach(this::createTask);\n\n    var result = getAllTasks();\n\n    assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);\n    assertThat(result.getBody())\n            .usingRecursiveFieldByFieldElementComparatorIgnoringFields("id")\n            .containsExactlyInAnyOrder(\n                    new TaskDto(null, "Some description", "open", null),\n                    new TaskDto(null, "Some other description", "open", null)\n            );\n    assertThat(result.getBody()).extracting(TaskDto::id).extracting(UUID::fromString).doesNotContainNull();\n  }\n\n  @Test\n  void completionStateOfTasksCanBeToggledAndTogglingOnlyChangesStateAndCompletionTime() {\n    var createdTask = createTask("Some description").getBody();\n    assertThat(createdTask.state()).isEqualTo("open");\n\n    var id = createdTask.id();\n\n    var toggledTask = toggleTask(id).getBody();\n    assertThat(toggledTask)\n            .usingRecursiveComparison()\n            .ignoringFields("state", "completionTime")\n            .isEqualTo(createdTask);\n    assertThat(toggledTask.state()).isEqualTo("completed");\n    assertThat(toggledTask.completionTime()).isNotNull();\n\n    var toggledTwiceTask = toggleTask(id).getBody();\n    assertThat(toggledTwiceTask).isEqualTo(createdTask);\n\n    var toggledThriceTask = toggleTask(id).getBody();\n    assertThat(toggledThriceTask)\n            .usingRecursiveComparison()\n            .ignoringFields("completionTime")\n            .isEqualTo(toggledTask);\n    assertThat(LocalDateTime.parse(toggledThriceTask.completionTime()))\n            .isAfter(LocalDateTime.parse(toggledTask.completionTime()));\n  }\n\n  private ResponseEntity<List<TaskDto>> getAllTasks() {\n    return restTemplate.exchange("/tasks", HttpMethod.GET, null, new ParameterizedTypeReference<>() {});\n  }\n\n  private ResponseEntity<TaskDto> createTask(String description) {\n    return restTemplate.postForEntity(\n            UriComponentsBuilder.fromPath("/tasks").queryParam("description", description).build().toUri(),\n            null,\n            TaskDto.class\n    );\n  }\n\n  private ResponseEntity<TaskDto> toggleTask(String id) {\n    return restTemplate.postForEntity("/tasks/toggle-completion/{id}", null, TaskDto.class, Map.of("id", id));\n  }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Was uns jetzt noch fehlt, ist die eingangs erw\xe4hnte Antikorruptionsschicht. Diese soll verhindern, dass Tasks mit leerer\nBeschreibung angelegt werden (was derzeit m\xf6glich w\xe4re, aber unserer Fachlichkeit widerspricht) oder aber, dass der\nBenutzer versucht, den ",(0,t.jsx)(n.em,{children:"Toggle"}),"-Endpunkt mit einem ",(0,t.jsx)(n.code,{children:"id"}),"-Wert aufzurufen, der keine g\xfcltige UUID darstellt (was\nderzeit zu einer Exception f\xfchren w\xfcrde)."]}),"\n",(0,t.jsx)(n.h2,{id:"datenintegrit\xe4t-durch-eine-antikorruptionsschicht",children:"Datenintegrit\xe4t durch eine Antikorruptionsschicht"}),"\n",(0,t.jsxs)(n.p,{children:["Der sicherlich g\xe4ngigste Weg im Spring-Umfeld zur Sicherstellung der Datenintegrit\xe4t an Endpunkten ist die Verwendung\nvon ",(0,t.jsx)(n.em,{children:"Bean Validation"}),". Diese erf\xfcllt den Zweck vollkommen und ist f\xfcr Produktivprojekte auch klar zu empfehlen. Da\ndieser\nMechanismus aber weitestgehend auf der Verwendung von Annotationen basiert, m\xf6chte ich hier zur besseren\nNachvollziehbarkeit stattdessen eine manuelle Implementierung vornehmen."]}),"\n",(0,t.jsxs)(n.p,{children:["In der Theorie siedelt sich eine solche Antikorruptionsschicht zwischen Adapter und Kernlogik an und soll daf\xfcr sorgen,\ndass die Kernlogik stets nur mit validen Daten aufgerufen wird. Das hat den immensen Vorteil, dass wir uns dann dort\nniemals Gedanken um invalide Zust\xe4nde machen m\xfcssen und daher dort auch nicht ",(0,t.jsx)(n.em,{children:"defensiv"})," programmieren m\xfcssen. Eine\nsolche\nSchicht macht daher nicht nur an der Grenze zu einem REST-Adapter Sinn, sondern \xfcberall, wo potenziell invalide\nDatens\xe4tze von der Au\xdfenwelt an uns herangetragen werden (wie etwa eine Datenbank, \xfcber die wir nicht die alleinige\nKontrolle haben, Message-Queues, Lesen vom Dateisystem)."]}),"\n",(0,t.jsxs)("figure",{style:{textAlign:"center"},children:[(0,t.jsx)("img",{src:s,alt:"missing",height:500}),(0,t.jsx)("figcaption",{children:"Antikorruptionsschicht: Zwischen Adapter und Kernlogik"})]}),"\n",(0,t.jsx)(n.p,{children:"Praktisch wollen wir diese Validierung der Daten daher im entsprechenden Adapter unterbringen, da diese nur dort\nSinn macht. Denn in anderen Adaptern haben wir vermutlich andere Austauschformate und ben\xf6tigen daher andere\nValidierungen."}),"\n",(0,t.jsxs)(n.p,{children:["Dazu werden wir uns nun einen ",(0,t.jsx)(n.code,{children:"RestApiValidator"})," unterhalb des REST-Adapter-Pakets in\n",(0,t.jsx)(n.code,{children:"de.colenet.hexagonal.todo.list.adapter.rest.validator"})," anlegen. Dieser soll uns zwei Methoden - ",(0,t.jsx)(n.code,{children:"validateId"}),"\nund ",(0,t.jsx)(n.code,{children:"validateDescription"})," - anbieten, die jeweils einen unvalidierten ",(0,t.jsx)(n.code,{children:"String"})," entgegennehmen und uns im Erfolgsfall\neine\nvalidierte ",(0,t.jsx)(n.code,{children:"UUID"}),", respektive einen validierten ",(0,t.jsx)(n.code,{children:"String"}),", zur\xfcckliefern."]}),"\n",(0,t.jsxs)(n.p,{children:["Hierzu verwenden wir\ndie ",(0,t.jsx)(n.a,{href:"https://docs.vavr.io/#_validation",children:"Validation API von Vavr"}),", die es uns auf elegante Art und Weise erlaubt,\nsolche Validierungen inklusive der Ber\xfccksichtigung von Fehlern zu implementieren. Insbesondere erlaubt uns diese API,\nmehrere\nfehlgeschlagene Validierungen zu kombinieren und so dem Benutzer direkt R\xfcckmeldung \xfcber jeglichen invaliden Input\nzur\xfcckzumelden (hierbei sprechen wir von einem ",(0,t.jsx)(n.em,{children:"Fail-Slow"})," Ansatz). Hierzu entschlie\xdfen wir uns, da wir im n\xe4chsten\nTeil der Serie unser Dom\xe4nenmodell erweitern wollen und wir dann f\xfcr den Endpunkt zum Anlegen eines neuen Tasks\nmehrere Parameter entgegennehmen werden.\nIm Gegensatz zum ",(0,t.jsx)(n.em,{children:"Fail-Slow"})," Ansatz w\xfcrde die - im Java-Umfeld g\xe4ngige - Methode, bei fehlgeschlagener Validierung\neine Exception zu werfen, nur den ersten Validierungsfehler zur\xfcckmelden (ein sogenannter ",(0,t.jsx)(n.em,{children:"Fail-Fast"})," Ansatz)."]}),"\n",(0,t.jsx)(n.admonition,{title:"Randbemerkung",type:"note",children:(0,t.jsxs)(n.p,{children:["Bei dem von uns gew\xe4hlten ",(0,t.jsx)(n.em,{children:"Fail-Slow"}),"-Ansatz handelt es sich um eine in der funktionalen Programmierung\ng\xe4ngigen Technik. Das Konzept ist in diesem Kontext als ",(0,t.jsx)(n.em,{children:"Validierung mittels applikativer Funktoren"})," gel\xe4ufig."]})}),"\n",(0,t.jsxs)(n.p,{children:["Kommen wir nun also zur Umsetzung des Validators. Zur Validierung der ",(0,t.jsx)(n.code,{children:"description"})," wollen wir nur\n\xfcberpr\xfcfen, dass sie nicht leer ist, und ansonsten eine entsprechende Fehlermeldung generieren:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public Validation<String, String> validateDescription(String description) {\n  if (!StringUtils.hasText(description)) {\n    return Validation.invalid("Description is mandatory");\n  }\n\n  return Validation.valid(description);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Der R\xfcckgabetyp ",(0,t.jsx)(n.code,{children:"Validation"})," ist hierbei ein von Vavr bereitgestelltes Interface, welches als ersten Typparameter\nden Typ des Fehlerobjekts und als zweiten Typparameter den Typ des Erfolgsobjekts erwartet. F\xfcr die Validierung\nunserer ID wird der zweite Typparameter daher ",(0,t.jsx)(n.code,{children:"UUID"})," sein und im n\xe4chsten Post werden wir auch eine Liste von\nStrings als Fehlertyp sehen."]}),"\n",(0,t.jsx)(n.p,{children:"Die Validierung der ID folgt demselben Schema, hier m\xfcssen wir jedoch zus\xe4tzlich pr\xfcfen, dass der Eingabewert eine\nvalide UUID darstellt."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'public Validation<String, UUID> validateId(String id) {\n  if (!StringUtils.hasText(id)) {\n    return Validation.invalid("ID is mandatory");\n  }\n\n  return Try.of(() -> UUID.fromString(id)).toValidation(__ -> "Not a valid UUID: " + id);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Mittels ",(0,t.jsx)(n.code,{children:"Try"})," fangen wir hier die von ",(0,t.jsx)(n.code,{children:"UUID::fromString"})," im Fehlerfall geworfene Exception und wandeln sie in\nein ",(0,t.jsx)(n.code,{children:"Validation"}),"-Objekt mit entsprechender Fehlermeldung um."]}),"\n",(0,t.jsxs)(n.p,{children:["Nun m\xfcssen wir diese Validierungen nur noch in unserem ",(0,t.jsx)(n.code,{children:"RestApiController"})," jeweils vor dem Aufruf der Kernlogik\nunterbringen. Dazu injizieren wir eine Instanz ",(0,t.jsx)(n.code,{children:"restApiValidator"})," des gerade entworfenen Validators in den Controller\nund erweitern unsere Methoden dort folgenderma\xdfen:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'@PostMapping(value = "/tasks", produces = MediaType.APPLICATION_JSON_VALUE)\nResponseEntity<?> createTask(@RequestParam String description) {\n  return restApiValidator\n          .validateDescription(description)\n          .map(taskService::createTask)\n          .map(restApiMapper::toDto)\n          .fold(RestApiController::createBadRequestResponse, RestApiController::createOkResponse);\n}\n\n@PostMapping(value = "/tasks/toggle-completion/{id}", produces = MediaType.APPLICATION_JSON_VALUE)\nResponseEntity<?> toggleCompletionState(@PathVariable String id) {\n  return restApiValidator\n          .validateId(id)\n          .map(taskService::toggleCompletionState)\n          .fold(\n                  RestApiController::createBadRequestResponse,\n                  toggledTask ->\n                          toggledTask\n                                  .map(restApiMapper::toDto)\n                                  .<ResponseEntity<?>>map(RestApiController::createOkResponse)\n                                  .orElseGet(() -> createBadRequestResponse("No task found for id: " + id))\n          );\n}\n\nprivate static ResponseEntity<String> createBadRequestResponse(String message) {\n  return new ResponseEntity<>(message, HttpStatus.BAD_REQUEST);\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Nat\xfcrlich haben wir im Repository auch Unittests f\xfcr den Validator mit aufgenommen und unsere bestehenden Tests\nerweitert."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Damit ist der erste Wurf unserer Anwendung komplett."})}),"\n",(0,t.jsx)(n.p,{children:"Probiert sie doch gerne mal aus: Legt Tasks an, lasst euch diese anzeigen, vervollst\xe4ndigt sie und setzt auch mal\nabsichtlich Requests mit invaliden Daten ab, wie etwa:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"POST http://localhost:8080/tasks?description=%20\nPOST http://localhost:8080/tasks/toggle-completion/not-a-valid-uuid\n"})}),"\n",(0,t.jsx)(n.h2,{id:"ausblick",children:"Ausblick"}),"\n",(0,t.jsx)(n.p,{children:"Im kommenden Teil wollen wir uns anschauen, wie sich eine Anpassung am Dom\xe4nenmodell auf die Anwendung auswirkt. Dazu\nwerden wir unseren Tasks ein F\xe4lligkeitsdatum hinzuf\xfcgen. Dieses werden wir dann auch nutzen, um die bisher noch\nunber\xfchrte Applikationsschicht mit Leben zu f\xfcllen, indem wir uns einen geplanten Auftrag anlegen, der uns regelm\xe4\xdfig\n\xfcber f\xe4llige Tasks benachrichtigt. Au\xdferdem wollen wir die M\xf6glichkeit bieten, beim Anwendungsstart automatisch einige\nBeispieltasks zu erzeugen."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},6549:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/banner-3c6221cdc4cb306e621cac5c416145fb.webp"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>d});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);