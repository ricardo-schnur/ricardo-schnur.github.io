"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[636],{1422:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"hexagonal-architecture-java-spring-boot-part-5","metadata":{"permalink":"/hexagonal-architecture-java-spring-boot-part-5","source":"@site/blog/hexagonal-architecture/part5/part5.mdx","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 5: Anbindung der Datenbank (am Beispiel einer MongoDB)","description":"banner","date":"2024-04-16T00:00:00.000Z","formattedDate":"16. April 2024","tags":[{"label":"Domain-driven Design","permalink":"/tags/domain-driven-design"},{"label":"Hexagonale Architektur","permalink":"/tags/hexagonale-architektur"},{"label":"Softwarearchitektur","permalink":"/tags/softwarearchitektur"},{"label":"Softwareentwicklung","permalink":"/tags/softwareentwicklung"}],"readingTime":7.91,"hasTruncateMarker":true,"authors":[{"name":"Ricardo Schnur","title":"Software Developer @ Colenet GmbH","url":"https://github.com/ricardo-schnur","imageURL":"img/profile.png","key":"ricardo"}],"frontMatter":{"slug":"hexagonal-architecture-java-spring-boot-part-5","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 5: Anbindung der Datenbank (am Beispiel einer MongoDB)","authors":"ricardo","tags":["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],"date":"2024-04-16T00:00:00.000Z"},"unlisted":false,"nextItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 4: Folgen einer \xc4nderung am Dom\xe4nenmodell und die Applikationsschicht","permalink":"/hexagonal-architecture-java-spring-boot-part-4"}},"content":"![banner](./banner.webp)\\n\\n> In seiner f\xfcnfteiligen Blogreihe erkl\xe4rt Ricardo die Vorteile von hexagonaler Architektur am Beispiel der Entwicklung\\n> einer To-Do-Listen-Anwendung. Im letzten Teil der Reihe wird das Projekt mit der Anbindung einer MongoDB\\n> abgeschlossen, was \u2013 dank der gew\xe4hlten Architektur \u2013 mit minimalem Aufwand m\xf6glich wird.\\n\\n{/* truncate */}\\n\\n<head>\\n    <link rel=\\"canonical\\"\\n          href=\\"https://www.colenet.de/blog/development/hexagonale-architektur-in-der-praxis-teil-5-anbindung-der-datenbank/\\"/>\\n</head>\\n\\nNachdem wir im Laufe dieser Serie eine voll funktionsf\xe4hige **To-Do-Listen-Anwendung** entwickelt haben (den kompletten\\nCode findet ihr auf [GitHub](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post5)),\\nwollen wir uns zum Abschluss noch anschauen, wie die gew\xe4hlte Architektur es uns erm\xf6glicht, ganz ohne \xc4nderungen am\\nApplikationskern und mit minimalem Aufwand **unseren In-Memory Cache durch eine persistente MongoDB zu ersetzen**.\\n\\n[Im ersten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-1) dieser Serie haben wir\\nein **frisches Java/Spring-Boot-Projekt aufgesetzt und konfiguriert**. Wir haben uns \xfcberlegt, wie wir uns die *\\n*Architektur\\nder Anwendung und ihre Umsetzung** vorstellen und diese Vorstellung mittels ArchUnit in einem **automatisierten\\nArchitekturtest** festgehalten.\\n\\n[Im zweiten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-2) sind wir mit der\\n**Modellierung der Dom\xe4ne**, der **Implementierung der Kernlogik** und der Datenhaltung der Anwendung in die eigentliche\\nEntwicklung gestartet.\\n\\n[Im dritten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-3) haben wir alle\\ngrundlegenden **Funktionalit\xe4ten unserer Anwendung implementiert**, sodass diese nutzbar wurde.\\n\\n[Im vierten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-4) haben wir uns\\nangesehen, welche Auswirkungen eine **Anpassung am Dom\xe4nenmodell** auf die bestehende Anwendung hat. Au\xdferdem wurde die\\n**Applikationsschicht** mit einer geplanten Aufgabe zum regelm\xe4\xdfigen Senden von Benachrichtigungen gef\xfcllt sowie mit der\\nM\xf6glichkeit, beim Anwendungsstart automatisch einige Beispieltasks zu erzeugen.\\n\\nNun geht es also noch darum, den In-Memory-Cache abzul\xf6sen durch eine persistente MongoDB \u2013 was dank unserer Architektur\\nmit minimalem Aufwand m\xf6glich wird.\\n\\n## Setup der MongoDB\\n\\nSolltet ihr bereits eine MongoDB-Instanz zur Verf\xfcgung haben, k\xf6nnt ihr diesen Schritt nat\xfcrlich \xfcberspringen. Ansonsten\\nstellt folgende Docker Compose Datei eine minimal lauff\xe4hige Konfiguration bereit, die f\xfcr unsere Zwecke v\xf6llig\\nausreicht:\\n\\n```yaml\\n# See https://hub.docker.com/_/mongo\\nservices:\\n  mongo:\\n    image: \\"mongo:6.0.7\\"\\n    restart: \\"unless-stopped\\"\\n    ports:\\n      - \\"27017:27017\\" # Map the port to make it accessible outside the container\\n    environment:\\n      MONGO_INITDB_ROOT_USERNAME: \\"root\\"\\n      MONGO_INITDB_ROOT_PASSWORD: \\"example\\" # Use secrets in a production application instead of plaintext passwords!\\n```\\n\\nIhr ben\xf6tigt hierzu Docker mit installiertem Compose-Plugin und k\xf6nnt die Datenbankinstanz dann mit dem Befehl\\n\\n```bash\\ndocker-compose -f mongodb-compose.yaml up\\n```\\n\\naufsetzen. Die Instanz ist dann auf Port `27017` mit den Zugangsdaten `root / example` ansprechbar. Diese Konfiguration\\nk\xf6nnt ihr nat\xfcrlich nach Belieben in der obigen Compose Datei anpassen.\\n\\nNachdem wir nun eine Datenbank zur Verf\xfcgung haben, wollen wir unsere Anwendung im n\xe4chsten Schritt mit dieser\\nverbinden.\\n\\n## Anbindung der Anwendung an die Datenbank\\n\\nIn einem ersten Schritt hinterlegen wir dazu die Verbindungsdaten in den `application.properties`:\\n\\n```properties\\n# MongoDB config\\nspring.data.mongodb.host=localhost\\nspring.data.mongodb.port=27017\\nspring.data.mongodb.authentication-database=admin\\nspring.data.mongodb.database=test\\nspring.data.mongodb.username=root\\nspring.data.mongodb.password=example\\n```\\n\\nIn einer produktiven Anwendung sollte das Passwort nat\xfcrlich in einem *Secret Manager* hinterlegt werden,\\ndiesen Umweg sparen wir uns aber an dieser Stelle.\\n\\nAls N\xe4chstes f\xfcgen wir die Abh\xe4ngigkeit *spring-boot-starter-data-mongodb* zu unserem Projekt in der `pom.xml` hinzu:\\n\\n```xml\\n\\n<dependency>\\n    <groupId>org.springframework.boot</groupId>\\n    <artifactId>spring-boot-starter-data-mongodb</artifactId>\\n</dependency>\\n```\\n\\nDiese kann, ohne weitere Zuarbeit unsererseits, mithilfe der eben hinterlegten Optionen nun eine Verbindung zur\\nDatenbank herstellen.\\n\\nSchlie\xdflich fehlt uns noch eine M\xf6glichkeit, zu entscheiden, ob wir wie bisher mit einem Cache oder mit der neuen\\nDatenbank arbeiten m\xf6chten. Dazu f\xfchren wir zuerst einen weiteren Konfigurationsparameter\\n\\n```properties\\n# Use \'cache\' or \'database\'\\nstorage.type=cache\\n```\\n\\nein und m\xfcssen zum Abschluss noch - basierend auf dem gesetzen Wert dieses Parameters - unsere Anwendung\\nentweder mit dem schon existierenden Cache-Adapter oder mit einem hypothetischen Datenbank-Adapter laden.\\n\\n## Bedingtes Laden von Komponenten\\n\\nUm dies zu erm\xf6glichen, werden wir nun Teile unserer Anwendung nur noch bedingt beim Anwendungsstart laden.\\nHierzu f\xfchren wir mehrere Anpassungen an unserer Einstiegsklasse `HexagonalToDoListApplication` durch.\\n\\nZuerst einmal schlie\xdfen wir sowohl den Cache-Adapter, als auch den noch zu implementierenden Datenbank-Adapter,\\nkomplett vom Anwendungsstart aus. Dazu hinterlegen wir folgende `@ComponentScan`-Konfiguration an der Klasse:\\n\\n```java\\n@ComponentScan(\\n        excludeFilters = {\\n                @ComponentScan.Filter(type = FilterType.REGEX, pattern = ADAPTER_PACKAGE + \\".cache.*\\"),\\n                @ComponentScan.Filter(type = FilterType.REGEX, pattern = ADAPTER_PACKAGE + \\".mongodb.*\\"),\\n        }\\n)\\n```\\n\\nHierbei verwenden wir die Konstante `String ADAPTER_PACKAGE = \\"de.colenet.hexagonal.todo.list.adapter\\"`.\\n\\nUm unsere Anwendung wie bisher mit einem Cache starten zu k\xf6nnen, legen wir eine neue, innere,\\nmit `@Configuration`-annotierte Klasse an, die einerseits den eben ausgeschlossenen Cache-Adapter wieder l\xe4dt,\\nfalls `storage.type=\\"cache\\"` gesetzt ist, und andererseits noch die *AutoConfiguration* der eben hinzugef\xfcgten\\nAbh\xe4ngigkeit unterdr\xfcckt. Letzteres schlie\xdfen wir an dieser Stelle statt in der Einstiegsklasse aus, da\\nansonsten (aufgrund der Art und Weise, wie *AutoConfiguration* in Spring funktioniert) erheblich mehr\\nKonfigurationsarbeit von uns zu leisten w\xe4re. Die entstandene Konfiguration sieht folgenderma\xdfen aus:\\n\\n```java\\n\\n@Configuration\\n@ComponentScan(ADAPTER_PACKAGE + \\".cache\\")\\n@ConditionalOnProperty(name = \\"storage.type\\", havingValue = \\"cache\\")\\n@EnableAutoConfiguration(\\n        exclude = {\\n                MongoAutoConfiguration.class, MongoDataAutoConfiguration.class, MongoRepositoriesAutoConfiguration.class,\\n        }\\n)\\nclass CacheConfiguration {}\\n```\\n\\nF\xfcr die Datenbank gehen wir analog vor, nur dass wir hier keine Anpassung an der *AutoConfiguration* ben\xf6tigen:\\n\\n```java\\n\\n@Configuration\\n@ComponentScan(ADAPTER_PACKAGE + \\".mongodb\\")\\n@ConditionalOnProperty(name = \\"storage.type\\", havingValue = \\"database\\")\\nclass DatabaseConfiguration {}\\n```\\n\\nStarten wir nun unsere Anwendung mit der Konfiguration `storage.type=\\"cache\\"`, so verh\xe4lt sich alles wie bisher.\\nVersuchen wir hingegen mit `storage.type=\\"database\\"` zu starten, wird dies derzeit noch nicht funktionieren, da\\nkeine Implementierung f\xfcr `TaskRepository` unter den geladenen Komponenten zu finden ist.\\nDas beheben wir nat\xfcrlich, indem wir im Folgenden abschlie\xdfend unseren Datenbank-Adapter implementieren.\\n\\nBemerkenswert ist an dieser Stelle, dass wir hiermit bereits jegliche Konfigurationsarbeit geleistet haben und\\nauch keinerlei weitere \xc4nderungen in unserem Bestandscode notwendig sind; wir werden im Folgenden (abgesehen von\\nTests) ausschlie\xdflich in einem neuen Adapter arbeiten. Dieser Umstand demonstriert deutlich einen der gro\xdfen\\nVorteile der hexagonalen Architektur: Infrastruktur\xe4nderungen haben nur sehr lokale Auswirkungen. Wir mussten nicht\\neine einzige Zeile Code in unserem Applikationskern oder in anderen Adaptern anpassen!\\n\\nKommen wir nun also endlich zum letzten Puzzleteil: Dem Datenbank-Adapter.\\n\\n## Implementation des Datenbank-Adapters\\n\\nHier passiert \xfcberhaupt nichts Neues mehr. Wir haben in den vorherigen Adaptern alle Techniken kennengelernt und\\ngehen hier v\xf6llig analog vor.\\n\\nZuerst legen wir uns eine geeignete Darstellung unseres Datenmodells f\xfcr den gegebenen Zweck zurecht.\\nWie im REST-Adapter auch, greifen wir hier auf eine Darstellung als reinen Produkttyp zur\xfcck, sind aber in unseren\\nZeittypen konkreter als dort, da diese hier entsprechend unterst\xfctzt werden:\\n\\n```java\\npublic record TaskEntity(\\n        String id,\\n        String description,\\n        LocalDate dueDate,\\n        boolean completed,\\n        LocalDateTime completionTime\\n) {}\\n```\\n\\nNat\xfcrlich brauchen wir an dieser Stelle dann auch wieder einen geeigneten *Mapper*, um zwischen dieser Darstellung\\nund unserem Dom\xe4nenmodell hin- und herwechseln zu k\xf6nnen:\\n\\n```java\\n\\n@Component\\npublic class MongoMapper {\\n\\n    public TaskEntity toEntity(Task model) {\\n        return new TaskEntity(\\n                model.id().toString(),\\n                model.description(),\\n                model.dueDate().orElse(null),\\n                switch (model) {\\n                    case OpenTask __ -> false;\\n                    case CompletedTask __ -> true;\\n                },\\n                switch (model) {\\n                    case OpenTask __ -> null;\\n                    case CompletedTask t -> t.completionTime();\\n                }\\n        );\\n    }\\n\\n    public Task toModel(TaskEntity entity) {\\n        return entity.completed() ? toCompletedTask(entity) : toOpenTask(entity);\\n    }\\n\\n    private static CompletedTask toCompletedTask(TaskEntity entity) {\\n        return new CompletedTask(\\n                UUID.fromString(entity.id()),\\n                entity.description(),\\n                Optional.ofNullable(entity.dueDate()),\\n                entity.completionTime()\\n        );\\n    }\\n\\n    private static OpenTask toOpenTask(TaskEntity entity) {\\n        return new OpenTask(UUID.fromString(entity.id()), entity.description(), Optional.ofNullable(entity.dueDate()));\\n    }\\n}\\n```\\n\\nWir haben nun also drei verschiedene Auspr\xe4gungen eines *Task*s. Einerseits unser rein durch die Fachlichkeit\\nmotiviertes Dom\xe4nenmodell `Task`, andererseits zwei zweckgebundene, durch die gew\xe4hlte Infrastruktur beeinflusste,\\nAuspr\xe4gungen `TaskDto` und `TaskEntity`. Diese k\xf6nnen wir nach Bedarf v\xf6llig unabh\xe4ngig voneinander evolvieren\\n(durch geeignete Anpassung an den entsprechenden *Mappern*) und sind so etwa gerade dazu in der Lage, unsere\\nPersistenzinfrastruktur grundlegend zu ver\xe4ndern, ohne die \xf6ffentliche API der Anwendung zu ver\xe4ndern.\\n\\nAls letzter Schritt bleibt jetzt also nur die Implementierung von `TaskRepository`. Hierzu legen wir erst ein Spring\\nData Repository\\n\\n```java\\n\\n@Repository\\npublic interface BaseMongoTaskRepository extends MongoRepository<TaskEntity, String> {\\n    List<TaskEntity> findByDueDateIsBeforeOrDueDateEquals(LocalDate beforeDate, LocalDate equalsDate);\\n\\n    default List<TaskEntity> findByDueDateIsBeforeOrDueDateEquals(LocalDate date) {\\n        return findByDueDateIsBeforeOrDueDateEquals(date, date);\\n    }\\n}\\n```\\n\\nan, welches die eigentliche Arbeit verrichten wird. In unserer Implementierung von `TaskRepository` werden wir jetzt\\nnur noch Aufrufe dieses Repositories, sowie des zuvor angelegten Mappers, auf geeignete Art und Weise zusammenf\xfcgen:\\n\\n```java\\n\\n@Repository\\nclass MongoTaskRepository implements TaskRepository {\\n\\n    private final BaseMongoTaskRepository baseMongoTaskRepository;\\n    private final MongoMapper mongoMapper;\\n\\n    MongoTaskRepository(BaseMongoTaskRepository baseMongoTaskRepository, MongoMapper mongoMapper) {\\n        this.baseMongoTaskRepository = baseMongoTaskRepository;\\n        this.mongoMapper = mongoMapper;\\n    }\\n\\n    @Override\\n    public Task save(Task task) {\\n        return Function1\\n                .of(mongoMapper::toEntity)\\n                .andThen(baseMongoTaskRepository::save)\\n                .andThen(mongoMapper::toModel)\\n                .apply(task);\\n    }\\n\\n    @Override\\n    public Optional<Task> find(UUID id) {\\n        return baseMongoTaskRepository.findById(id.toString()).map(mongoMapper::toModel);\\n    }\\n\\n    @Override\\n    public List<Task> getAll() {\\n        return baseMongoTaskRepository.findAll().stream().map(mongoMapper::toModel).toList();\\n    }\\n\\n    @Override\\n    public List<OpenTask> getAllOpenTasksWithDueDateBeforeOrEqual(LocalDate date) {\\n        return baseMongoTaskRepository\\n                .findByDueDateIsBeforeOrDueDateEquals(date)\\n                .stream()\\n                .map(mongoMapper::toModel)\\n                // Should probably be filtered in the database call in production applications!\\n                .filter(OpenTask.class::isInstance)\\n                .map(OpenTask.class::cast)\\n                .toList();\\n    }\\n}\\n```\\n\\nDamit haben wir unsere Implementierung endlich abgeschlossen und k\xf6nnen unsere Anwendung schlie\xdflich mit der\\nKonfiguration `storage.type=\\"database\\"` starten und unsere Tasks persistent in der anfangs angelegten Datenbank\\nspeichern.\\n\\n:::note[Randbemerkung: Testing]\\n\\nUm sicherzustellen, dass unser neuer Datenbank-Adapter nichts am Verhalten der Anwendung \xe4ndert, habe ich die bereits\\nexistierenden Integrations- und End-To-End-Tests so abstrahiert, dass sie sowohl gegen den Cache- als auch gegen den\\nDatenbank-Adapter gefahren werden k\xf6nnen. Das liefert uns zumindest eine gewisse Konfidenz, dass sich die beiden\\nPersistenz-Modi in ihrem Verhalten nach au\xdfen nicht unterscheiden.\\n\\nAuch wenn Testing nicht im Fokus dieser Reihe lag,\\nlade ich euch dazu ein, euch die Details hierzu\\nim [Repository](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post5) anzuschauen.\\n\\n:::\\n\\n## Die Vorteile hexagonaler Architektur nutzen\\n\\nHiermit sind wir am Ende unserer Reise angelangt. Zu Beginn des ersten Teils habe ich der hexagonalen Architektur\\nVorteile wie etwa ein **dom\xe4nenzentriertes Design**, **Flexibilit\xe4t** und eine **klare Projektstruktur** zugeschrieben.\\nIn diesem\\nTeil konnten wir au\xdferdem sehen, **dass das Infrastrukturthema *Cache oder Datenbank* zur Datenhaltung keine einzige\\nZeile\\nan Code\xe4nderungen in der Dom\xe4nenschicht erforderte**. H\xe4tten wir unsere Anforderung leicht abge\xe4ndert zu *Cache durch\\nDatenbank ersetzen*, w\xe4ren noch nicht einmal die \xc4nderungen zum bedingten Laden von Komponenten notwendig gewesen\\nund wir\\nh\xe4tten einzig den Cacheadapter durch einen Datenbankadapter ersetzen m\xfcssen.\\n\\nIhr habt in dieser Reihe einen von vielen m\xf6glichen Wegen gesehen, wie sich eine **hexagonale Architektur in Java mit\\nSpring** umsetzen l\xe4sst. Die gelernte Vorgehensweise l\xe4sst sich aber nat\xfcrlich konzeptuell auch auf andere Sprachen und\\nFrameworks \u2013 mit entsprechenden technischen Anpassungen \u2013 \xfcbertragen.\\n\\nProbiert es in eurem n\xe4chsten Projekt doch mal aus!"},{"id":"hexagonal-architecture-java-spring-boot-part-4","metadata":{"permalink":"/hexagonal-architecture-java-spring-boot-part-4","source":"@site/blog/hexagonal-architecture/part4/part4.mdx","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 4: Folgen einer \xc4nderung am Dom\xe4nenmodell und die Applikationsschicht","description":"banner","date":"2024-02-27T00:00:00.000Z","formattedDate":"27. Februar 2024","tags":[{"label":"Domain-driven Design","permalink":"/tags/domain-driven-design"},{"label":"Hexagonale Architektur","permalink":"/tags/hexagonale-architektur"},{"label":"Softwarearchitektur","permalink":"/tags/softwarearchitektur"},{"label":"Softwareentwicklung","permalink":"/tags/softwareentwicklung"}],"readingTime":10.145,"hasTruncateMarker":true,"authors":[{"name":"Ricardo Schnur","title":"Software Developer @ Colenet GmbH","url":"https://github.com/ricardo-schnur","imageURL":"img/profile.png","key":"ricardo"}],"frontMatter":{"slug":"hexagonal-architecture-java-spring-boot-part-4","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 4: Folgen einer \xc4nderung am Dom\xe4nenmodell und die Applikationsschicht","authors":"ricardo","tags":["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],"date":"2024-02-27T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 5: Anbindung der Datenbank (am Beispiel einer MongoDB)","permalink":"/hexagonal-architecture-java-spring-boot-part-5"},"nextItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht","permalink":"/hexagonal-architecture-java-spring-boot-part-3"}},"content":"![banner](./banner.webp)\\n\\n> Ricardo zeigt uns in dieser Blog-Reihe die Vorteile von hexagonaler Architektur anhand der Entwicklung einer\\n> To-Do-Listen-Anwendung. Im 4. Teil wird das Dom\xe4nenmodell erweitert und die Applikationsschicht mit einer\\n> geplanten Aufgabe gef\xfcllt.\\n\\n{/* truncate */}\\n\\n<head>\\n    <link rel=\\"canonical\\"\\n          href=\\"https://www.colenet.de/blog/development/hexagonale-architektur-in-der-praxis-teil-4-aenderung-am-domanenmodell-und-applikationsschicht/\\"/>\\n</head>\\n\\n\\nDiese Artikel-Reihe ist der hexagonalen Architektur gewidmet: Wir m\xf6chten ihre Grundprinzipien verstehen und diese in\\nder Praxis erleben. Wir werden uns anschauen, wie sich eine hexagonale Architektur in einer typischen Webanwendung\\npraktisch realisieren l\xe4sst. Dazu werden wir Schritt f\xfcr Schritt eine kleine **To-do-Listen-Anwendung** entwickeln, die\\nes\\nerm\xf6glichen soll, Tasks anzulegen, angelegte Tasks anzuzeigen und Tasks als erledigt zu markieren. Die Anwendung wird\\n\xfcber eine REST-Schnittstelle bedienbar sein und die Tasks werden konfigurierbar entweder In-Memory oder persistent in\\neiner echten MongoDB verwaltet.\\n\\n[Im ersten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-1) dieser Serie haben wir\\nein frisches Java/Spring-Boot-Projekt aufgesetzt und konfiguriert. Wir haben uns\\n\xfcberlegt, wie wir uns die Architektur der Anwendung und ihre Umsetzung vorstellen und diese Vorstellung mittels ArchUnit\\nin einem automatisierten Architekturtest festgehalten.\\n\\n[Im zweiten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-2) sind wir mit der\\nModellierung der Dom\xe4ne, der Implementierung der Kernlogik und der Datenhaltung der\\nAnwendung in die eigentliche Entwicklung gestartet.\\n\\n[Im dritten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-3) haben wir alle\\ngrundlegenden Funktionalit\xe4ten unserer Anwendung implementiert, sodass diese bereits\\nnutzbar ist.\\n\\nNun m\xf6chten wir uns einerseits anschauen, welche Auswirkungen eine **Anpassung am Dom\xe4nenmodell** auf die bestehende\\nAnwendung hat und au\xdferdem die bis dato noch unbeachtete **Applikationsschicht** mit einer geplanten Aufgabe zum\\nregelm\xe4\xdfigen Senden von Benachrichtigungen f\xfcllen sowie der M\xf6glichkeit, beim Anwendungsstart automatisch einige\\nBeispieltasks zu erzeugen.\\n\\n:::info\\n\\nIhr findet den aktuellen Stand des Projekts sowie die \xc4nderungen auch aus diesem Teil\\nauf [GitHub](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post4).\\n\\n:::\\n\\n## Erweiterung des Dom\xe4nenmodells\\n\\nUnsere Anforderung soll recht simpel gehalten werden. Wir wollen unserem Task eine neue Eigenschaft\\n*F\xe4lligkeitsdatum* hinzuf\xfcgen. Hierbei soll es sich um eine optionale Eigenschaft handeln und sie soll sowohl bei\\noffenen als auch (zur Nachvollziehbarkeit) bei geschlossenen Tasks vorhanden sein.\\n\\nIn einem ersten Schritt wollen wir nur diese neue Eigenschaft hinzuf\xfcgen und uns anschauen, an welchen Stellen\\nunserer Anwendung wir dazu alles Anpassungen vornehmen m\xfcssen. Im Anschluss daran werden wir unsere Anwendung dann um\\nautomatische F\xe4lligkeitsbenachrichtigungen erweitern.\\n\\nDie Erweiterung unseres Modells gestaltet sich denkbar einfach - wir f\xfcgen lediglich die neue Eigenschaft in den\\nbeiden `record`s `OpenTask` und `CompletedTask` hinzu. Au\xdferdem nehmen wir sie in das Interface `Task` mit auf:\\n\\n```java\\npublic sealed interface Task {\\n    UUID id();\\n    String description();\\n    Optional<LocalDate> dueDate();\\n\\n    record OpenTask(UUID id, String description, Optional<LocalDate> dueDate) implements Task {}\\n\\n    record CompletedTask(UUID id, String description, Optional<LocalDate> dueDate, LocalDateTime completionTime)\\n            implements Task {}\\n}\\n```\\n\\nJetzt k\xf6nnen wir uns vom Typsystem und dem Compiler leiten lassen. Als Erstes f\xe4llt uns direkt auf, dass den\\nKonstruktoraufrufen in `TaskService` nun einen Parameter fehlt. Dies beheben wir, indem wir einerseits in\\n`withToggledCompletionState` den jeweils neuen Parameter mit \xfcbergeben\\n\\n```java\\nprivate Task withToggledCompletionState(Task task) {\\n    return switch (task) {\\n        case OpenTask t -> new CompletedTask(t.id(), t.description(), t.dueDate(), LocalDateTime.now(clock));\\n        case CompletedTask t -> new OpenTask(t.id(), t.description(), t.dueDate());\\n    };\\n}\\n```\\n\\nund andererseits in `createTask` die Methodensignatur um einen entsprechenden Parameter erweitern und diesen\\nweiterreichen:\\n\\n```java\\npublic Task createTask(String description, Optional<LocalDate> dueDate) {\\n    return taskRepository.save(new OpenTask(UUID.randomUUID(), description, dueDate));\\n}\\n```\\n\\nDurch diese Signatur\xe4nderung wird nun nat\xfcrlich der Aufruf dieser Methode aus `RestApiController` heraus ung\xfcltig.\\n\\nUm das zu beheben, m\xfcssen wir uns ein wenig mehr anstrengen. Wir erweitern auch hier wieder\\ndie Signatur, um den neuen Parameter auch im REST-Aufruf mitgeben zu k\xf6nnen:\\n\\n```java\\nResponseEntity<?> createTask(@RequestParam String description, @RequestParam @Nullable String dueDate)\\n```\\n\\nAuff\xe4llig ist hier der Typ `@Nullable String`. Diesen w\xe4hlen wir, damit unser Endpunkt auch weiterhin ohne\\ndiesen Parameter aufrufbar ist und wir Serialisierbarkeit gew\xe4hrleisten. Im Gegensatz dazu haben wir uns im\\nDom\xe4nenmodell f\xfcr den Typ `Optional<LocalDate>` entschieden, der einerseits mit `LocalDate` spezifischer als\\n`String` ist und andererseits die Optionalit\xe4t der Eigenschaft durch `Optional` explizit macht und dadurch Benutzer\\ndazu zwingt, damit umzugehen. Als N\xe4chstes erweitern wir unseren `RestApiValidator`. Hier wollen wir die bestehende\\nMethode\\n\\n```java\\nValidation<String, String> validateDescription(String description)\\n```\\n\\nabl\xf6sen durch:\\n\\n```java\\nValidation<Seq<String>, Tuple2<String, Optional<LocalDate>>> validateCreateTaskParameters(\\n        String description,\\n        String dueDate\\n)\\n```\\n\\nDiese soll uns also im Erfolgsfall ein Tupel bestehend aus der, wie bisher validierten `description`, aber erweitert\\num ein validiertes und in den erwarteten Typ umgewandeltes `dueDate` zur\xfcckgeben. Im Fehlerfall wollen wir\\nau\xdferdem `Seq<String>` statt nur `String` zur\xfcckgeben, um gegebenenfalls f\xfcr beide Validierungen eine\\nFehlernachricht bereitstellen zu k\xf6nnen. Bei `Seq` (f\xfcr *Sequence*) handelt es sich hierbei um einen von Vavr\\nbereitgestellten Typ.\\n\\nHierzu bauen wir uns erst eine dedizierte Validierungsfunktion f\xfcr das `dueDate`,\\ndie uns entweder ein leeres `Optional` oder aber das geparste Datum liefert:\\n\\n```java\\nprivate static Validation<String, Optional<LocalDate>> validateDueDate(String dueDate) {\\n    if (!StringUtils.hasText(dueDate)) {\\n        return Validation.valid(Optional.empty());\\n    }\\n\\n    return Try\\n            .success(dueDate)\\n            .mapTry(LocalDate::parse)\\n            .map(Optional::of)\\n            .toValidation(__ -> \\"Due date has to be in format yyyy-MM-dd: \\" + dueDate);\\n}\\n```\\n\\nDiese Methode kombinieren wir dann mit `validateDescription` zu:\\n\\n```java\\npublic Validation<Seq<String>, Tuple2<String, Optional<LocalDate>>> validateCreateTaskParameters(\\n        String description,\\n        String dueDate\\n) {\\n    return Validation.combine(validateDescription(description), validateDueDate(dueDate)).ap(Tuple::of);\\n}\\n```\\n\\nSchlie\xdflich passen wir noch den Aufruf in `RestApiController::createTask` an, indem wir die bestehende Implementierung\\n\\n```java\\nreturn restApiValidator\\n    .validateDescription(description)\\n    .map(taskService::createTask)\\n    .map(restApiMapper::toDto)\\n    .fold(RestApiController::createBadRequestResponse, RestApiController::createOkResponse);\\n```\\n\\nersetzen durch:\\n\\n```java\\nreturn restApiValidator\\n    .validateCreateTaskParameters(description, dueDate)\\n    .map(Function2.of(taskService::createTask).tupled())\\n    .map(restApiMapper::toDto)\\n    .mapError(messages -> String.join(\\"; \\", messages))\\n    .fold(RestApiController::createBadRequestResponse, RestApiController::createOkResponse);\\n```\\n\\nWir validieren also nun beide Parameter und reichen diese dann an den Service weiter. Im Fehlerfall konkatenieren\\nwir au\xdferdem alle Nachrichten zu einer einzigen Nachricht, die wir dann in die Response aufnehmen.\\n\\nSofern wir auch unsere Testklassen entsprechend angepasst haben, ist unsere Anwendung nun wieder kompilierbar und\\nnutzbar. Auch ist es uns jetzt m\xf6glich, Tasks mit einem F\xe4lligkeitsdatum via REST-Aufruf anzulegen. Auff\xe4llig ist aber,\\ndass alle Antworten unserer Endpunkte *kein* F\xe4lligkeitsdatum mitliefern.\\n\\nIn erster Linie gilt hier aber v\xf6llig unironisch das Motto *It\'s not a bug, it\'s a feature.* Dieser Umstand zeigt\\nn\xe4mlich, dass wir *nicht* aus Versehen implizit unsere Schnittstelle ver\xe4ndert haben, sondern dies durch die\\nEntkopplung von `Task` zu `TaskDto` eine bewusste Entscheidung sein muss. Da wir besagte \xc4nderung an dieser Stelle\\naber nat\xfcrlich guthei\xdfen, f\xfcgen wir die neue Eigenschaft in einem letzten Schritt noch zu unserem Austauschmodell hinzu\\n\\n```java\\npublic record TaskDto(String id, String description, String dueDate, String state, String completionTime) {}\\n```\\n\\nund erweitern die Methode `RestApiMapper::toDto` um eine entsprechende Zeile:\\n\\n```java\\nmodel.dueDate().map(LocalDate::toString).orElse(null)\\n```\\n\\nDamit enthalten schlie\xdflich auch alle Antworten unserer Endpunkte die neue Eigenschaft. Im folgenden Abschnitt\\nwollen wir das neu hinzugef\xfcgte F\xe4lligkeitsdatum nutzen, um automatisiert F\xe4lligkeitsbenachrichtigungen zu versenden.\\n\\n## Die Applikationsschicht: Automatische F\xe4lligkeitsbenachrichtigungen\\n\\nAuch hier wollen wir die Anforderungen zu Demonstrationszwecken m\xf6glichst simpel halten: Wir wollen in regelm\xe4\xdfigen\\nAbst\xe4nden all unsere offenen Tasks anschauen, pr\xfcfen, ob das F\xe4lligkeitsdatum \xfcberschritten ist, und in diesem Fall\\neine Benachrichtigung senden. Dazu implementieren wir eine geplante Aufgabe mittels der von Spring\\nbereitgestellten `@Scheduled` Annotation und lassen diese in einem fixen Intervall laufen.\\n\\nSolche geplanten Aufgaben sind ein typisches Beispiel f\xfcr Code, den wir in der Applikationsschicht unterbringen.\\nDenn weder handelt es sich hierbei um Kernlogik, sodass die Dom\xe4ne der falsche Ort daf\xfcr ist, noch haben wir hier\\neine Anbindung an die Au\xdfenwelt, was f\xfcr einen Adapter sprechen w\xfcrde. Andere typische Themen, die in der\\nApplikationsschicht ihren Platz finden, sind etwa Transaktionsmanagement, die Zusammenf\xfchrung mehrerer\\nTeile der Kernlogik zu einem Workflow oder einmalige Aufgaben, die beim Anwendungsstart erledigt werden m\xfcssen\\n(hierf\xfcr sehen wir sp\xe4ter noch ein Beispiel).\\n\\nWir starten also mit einer neuen Klasse\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.application.scheduler;\\n\\n@Component\\nclass DueNotificationScheduler {}\\n```\\n\\nin der wir eine Methode\\n\\n```java\\n@Scheduled(fixedRateString = \\"${notification.interval}\\", timeUnit = TimeUnit.SECONDS)\\nvoid sendDueNotifications()\\n```\\n\\nimplementieren m\xf6chten. Das Benachrichtigungsintervall wollen wir hierbei\\nkonfigurierbar halten und legen daf\xfcr den Parameter `notification.interval` in den `application.properties` an und\\nbelegen diesen dort mit einem geeigneten Wert, etwa `notification.interval=60` f\xfcr eine min\xfctliche Benachrichtigung.\\n\\nAu\xdferdem m\xfcssen wir den Scheduling-Mechanismus von Spring \xfcberhaupt erst aktivieren, indem wir unsere\\nEinstiegsklasse mit `@EnableScheduling` annotieren:\\n\\n```java\\n@SpringBootApplication\\n@EnableScheduling\\nclass HexagonalToDoListApplication\\n```\\n\\nDamit haben wir die Grundlagen geschaffen und k\xf6nnen uns jetzt dem Inhalt der Methode `sendDueNotifications` widmen.\\nDiese soll erst alle f\xe4lligen, offenen Tasks laden und dann f\xfcr jede davon eine Benachrichtigung senden.\\n\\nZum Laden der Tasks erweitern wir unseren `TaskService` um eine Methode\\n\\n```java\\nList<OpenTask> getAllOpenTasksWithDueDateBeforeOrEqual(LocalDate date)\\n```\\n\\nDiese soll, wie der Name sagt, alle offenen Tasks zur\xfcckgeben, die ein F\xe4lligkeitsdatum vor oder gleich dem\\nangegebenen Datum haben. Auf die genaue Umsetzung wollen wir an dieser Stelle nicht genau eingehen (wir w\xfcrden dabei\\nnichts Neues sehen). Die Grundidee ist aber nat\xfcrlich, auch eine entsprechende Methode im Repository anzubieten und\\ndiese basierend auf unserem Cache umzusetzen. Die Details dazu k\xf6nnt ihr euch gerne\\nim[GitHub Repository](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post4) anschauen.\\n\\nDas Senden der Benachrichtigungen wollen wir dann wiederrum in entsprechende Adapter auslagern. Dazu definieren wir\\nuns wie gehabt einen Port\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.application.scheduler;\\n\\nimport de.colenet.hexagonal.todo.list.domain.model.task.Task.OpenTask;\\n\\npublic interface DueNotificationSender {\\n    void sendDueNotification(OpenTask task);\\n}\\n```\\n\\nden wir dann sp\xe4ter durch einen konkreten Adapter realisieren.\\n\\nErst einmal sind wir jetzt aber in der Lage, den Scheduler zu vervollst\xe4ndigen:\\n\\n```java\\n@Component\\nclass DueNotificationScheduler {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(DueNotificationScheduler.class);\\n\\n    private final Clock clock;\\n    private final DueNotificationSender dueNotificationSender;\\n    private final TaskService taskService;\\n\\n    DueNotificationScheduler(Clock clock, DueNotificationSender dueNotificationSender, TaskService taskService) {\\n        this.clock = clock;\\n        this.dueNotificationSender = dueNotificationSender;\\n        this.taskService = taskService;\\n    }\\n\\n    @Scheduled(fixedRateString = \\"${notification.interval}\\", timeUnit = TimeUnit.SECONDS)\\n    void sendDueNotifications() {\\n        LOGGER.info(\\"Sending due notifications\\");\\n\\n        taskService\\n            .getAllOpenTasksWithDueDateBeforeOrEqual(LocalDate.now(clock))\\n            .forEach(dueNotificationSender::sendDueNotification);\\n\\n        LOGGER.info(\\"Finished sending due notifications\\");\\n    }\\n}\\n```\\n\\nUm auf den ersten Blick sehen zu k\xf6nnen, wann unsere Aufgabe ausgef\xfchrt wird, haben wir hier au\xdferdem noch ein paar\\nLogeintr\xe4ge hinzugef\xfcgt.\\n\\nEs fehlt uns jetzt also nur noch ein konkreter Adapter, der den eben definierten Port realisiert. Hierf\xfcr haben wir uns\\nalle M\xf6glichkeiten offen gelassen: Wir k\xf6nnten eine E-Mail versenden, unseren favorisierten Chat-Client wie etwa Slack\\nverwenden, Push-Benachrichtigungen auf Mobilger\xe4ten erzeugen oder was auch immer wir sonst m\xf6chten.\\n\\nHier w\xe4hlen wir aber die denkbar einfachste Variante und wollen als \u201eBenachrichtigung\u201d einfach den f\xe4lligen Task loggen.\\nDazu registrieren wir zuerst in unserem Architekturtest einen neuen Adapter:\\n\\n```java\\n.adapter(\\"console\\", getAdapterIdentifier(\\"console\\"))\\n```\\n\\nAu\xdferdem vervollst\xe4ndigen wir an dieser Stelle noch ein offenes To-do und entfernen folgende Zeile\\n\\n```java\\n.withOptionalLayers(true) // TODO Remove this as soon as our layers are filled\\n```\\n\\ndenn all unsere Schichten sind inzwischen mit Inhalt gef\xfcllt (mal abgesehen von dem gerade registrierten\\n`console`-Adapter, aber dazu kommen wir nun).\\n\\nWie bereits erw\xe4hnt wollen wir in diesem neuen Adapter einfach einen Logeintrag als Benachrichtigung erzeugen. Dazu\\nist folgende Implementierung v\xf6llig ausreichend:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.adapter.console;\\n\\nimport ...; // Omitted for clarity\\n\\n@Component\\nclass DueNotificationLogger implements DueNotificationSender {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(DueNotificationLogger.class);\\n\\n    public void sendDueNotification(OpenTask task) {\\n        LOGGER.warn(\\"Task is due: {}\\", task);\\n    }\\n}\\n```\\n\\nStarten wir nun unsere Anwendung und legen uns einen offenen Task mit F\xe4lligkeitsdatum in der Vergangenheit an\\n(etwa via `POST http://localhost:8080/tasks?description=Due&dueDate=2023-07-01`), so sehen wir innerhalb k\xfcrzester\\nZeit (nat\xfcrlich abh\xe4ngig vom Parameter `notification.interval`) folgende Logeintr\xe4ge (zur \xdcbersichtlichkeit aufs\\nWesentliche reduziert):\\n\\n```\\nINFO: Sending due notifications\\nWARN: Task is due: OpenTask[id=5d3fcb2d-b8c9-47d2-9ba9-c95e7be05b65, description=Due, dueDate=Optional[2023-07-01]]\\nINFO: Finished sending due notifications\\n```\\n\\nAbschlie\xdfend wollen wir noch aus Bequemlichkeit zum Anwendungsstart automatisch einige Beispieltasks anlegen, um\\nunsere neuen Benachrichtigungen sofort beobachten zu k\xf6nnen, ohne manuell f\xe4llige Tasks anlegen zu m\xfcssen.\\n\\n## Erzeugung von Beispieltasks\\n\\nWie erw\xe4hnt handelt es sich auch hierbei um eine Aufgabe, die sich typischerweise in der Applikationsschicht ansiedelt.\\nHierzu bauen wir uns lediglich eine neue Klasse `ExampleTaskCreator` in\\n`de.colenet.hexagonal.todo.list.application.startup`, die eine Handvoll `Task`-Objekte erzeugt und diese dann mittels\\n`TaskRepository::save` abspeichert. Au\xdferdem wollen wir dieses Verhalten dynamisch ein- und ausschaltbar machen und\\nlegen uns dazu eine neue Eigenschaft `startup.exampletasks.create` in den `application.properties` an, die wir mit\\n`true` vorkonfigurieren. Da wir diesen Prozess einmalig nach dem Anwendungsstart ausf\xfchren wollen, kennzeichnen wir\\ndie entsprechende Methode au\xdferdem mit `@EventListener(ApplicationReadyEvent.class)`. Alles in allem landen wir bei\\nfolgender Implementierung:\\n\\n```java\\n@Component\\n@ConditionalOnProperty(prefix = \\"startup\\", name = \\"exampletasks.create\\", havingValue = \\"true\\")\\nclass ExampleTaskCreator {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(ExampleTaskCreator.class);\\n\\n    private final TaskRepository taskRepository;\\n\\n    ExampleTaskCreator(TaskRepository taskRepository) {\\n        this.taskRepository = taskRepository;\\n    }\\n\\n    @EventListener(ApplicationReadyEvent.class)\\n    public void createExampleTasks() {\\n        LOGGER.info(\\"Creating some example tasks\\");\\n\\n        Stream\\n            .of(\\n                new CompletedTask(\\n                    UUID.randomUUID(),\\n                    \\"[EXAMPLE] This task was completed yesterday\\",\\n                    Optional.empty(),\\n                    LocalDateTime.now().minusDays(1L)\\n                ),\\n                // ... more example tasks\\n            )\\n            .forEach(taskRepository::save);\\n\\n        LOGGER.info(\\"Example tasks successfully created\\");\\n    }\\n}\\n```\\n\\n## Ausblick\\n\\nDamit sind wir fast am Ende der Reihe angelangt. Unsere Applikation beinhaltet nun jegliche beabsichtigte Funktionalit\xe4t\\nund wir haben alle Schichten der hexagonalen Architektur in Verwendung gesehen.\\n\\nIn n\xe4chsten und gleichzeitig letzten Teil der Reihe wollen wir uns schlie\xdflich noch anschauen, wie wir unseren In-Memory\\nCache durch eine echte, persistente Datenbank ersetzen k\xf6nnen. Dazu werden wir exemplarisch eine MongoDB verwenden.\\nKonzeptuell l\xe4sst sich die Vorgehensweise aber nat\xfcrlich auch auf andere Datenbanken \xfcbertragen."},{"id":"hexagonal-architecture-java-spring-boot-part-3","metadata":{"permalink":"/hexagonal-architecture-java-spring-boot-part-3","source":"@site/blog/hexagonal-architecture/part3/part3.mdx","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht","description":"banner","date":"2024-01-08T00:00:00.000Z","formattedDate":"8. Januar 2024","tags":[{"label":"Domain-driven Design","permalink":"/tags/domain-driven-design"},{"label":"Hexagonale Architektur","permalink":"/tags/hexagonale-architektur"},{"label":"Softwarearchitektur","permalink":"/tags/softwarearchitektur"},{"label":"Softwareentwicklung","permalink":"/tags/softwareentwicklung"}],"readingTime":10.135,"hasTruncateMarker":true,"authors":[{"name":"Ricardo Schnur","title":"Software Developer @ Colenet GmbH","url":"https://github.com/ricardo-schnur","imageURL":"img/profile.png","key":"ricardo"}],"frontMatter":{"slug":"hexagonal-architecture-java-spring-boot-part-3","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht","authors":"ricardo","tags":["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],"date":"2024-01-08T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 4: Folgen einer \xc4nderung am Dom\xe4nenmodell und die Applikationsschicht","permalink":"/hexagonal-architecture-java-spring-boot-part-4"},"nextItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 2: Modellierung, Kernlogik und In-Memory Cache","permalink":"/hexagonal-architecture-java-spring-boot-part-2"}},"content":"![banner](./banner.webp)\\n\\n> Um zu verstehen, wie hexagonale Architektur die Art und Weise, Software zu entwickeln, ver\xe4ndert und was dabei\\n> die Vorteile sind, f\xfchrt Ricardo uns Schritt f\xfcr Schritt durch die Entwicklung einer To-Do-Listen-Anwendung.\\n> Im 3. Teil wird nun \xfcber eine REST-Schnittstelle die Anwendung interaktiv nutzbar gemacht und die Datenintegrit\xe4t\\n> durch eine Antikorruptionsschicht sichergestellt.\\n\\n{/* truncate */}\\n\\n<head>\\n    <link rel=\\"canonical\\"\\n          href=\\"https://www.colenet.de/blog/development/hexagonale-architektur-in-der-praxis-teil-3-rest-schnittstelle-mit-antikorruptionsschicht/\\"/>\\n</head>\\n\\n\\nimport antiCorruptionLayer from \'./anti_corruption_layer.png\';\\n\\nDiese Artikel-Reihe ist der hexagonalen Architektur gewidmet: Wir m\xf6chten ihre Grundprinzipien verstehen und diese in\\nder Praxis erleben. Wir werden uns anschauen, wie sich eine hexagonale Architektur in einer typischen Webanwendung\\npraktisch realisieren l\xe4sst. Dazu werden wir Schritt f\xfcr Schritt eine kleine **To-do-Listen-Anwendung** entwickeln, die\\nes\\nerm\xf6glichen soll, Tasks anzulegen, angelegte Tasks anzuzeigen und Tasks als erledigt zu markieren. Die Anwendung wird\\n\xfcber eine REST-Schnittstelle bedienbar sein und die Tasks werden konfigurierbar entweder In-Memory oder persistent in\\neiner echten MongoDB verwaltet.\\n\\n[Im ersten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-1) dieser Serie haben wir\\nein frisches Java/Spring-Boot-Projekt aufgesetzt und konfiguriert. Wir haben uns\\n\xfcberlegt, wie wir uns die Architektur der Anwendung und ihre Umsetzung vorstellen und diese Vorstellung mittels ArchUnit\\nin einem automatisierten Architekturtest festgehalten.\\n\\n[Im zweiten Teil](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-2) sind wir mit der\\nModellierung der Dom\xe4ne, der Implementierung der Kernlogik und der Datenhaltung der\\nAnwendung in die eigentliche Entwicklung gestartet.\\n\\nNun m\xf6chten wir unsere Anwendung auch interaktiv nutzbar machen und zu diesem Zweck eine REST-Schnittstelle\\nbereitstellen.\\nGenauer m\xf6chten wir\\n\\n* einen `GET`-Endpunkt `/task`, der uns alle existierenden Tasks zur\xfcckliefert,\\n* einen `POST`-Endpunkt `/task`, der es uns erlaubt, einen neuen Task anzulegen und den angelegten Task zur\xfcckliefert,\\n  sowie\\n* einen `POST`-Endpunkt `/task/toggle-completion/{id}`, der es uns erlaubt, den Zustand eines existierenden\\n  Tasks umzuschalten und den umgeschalteten Task zur\xfcckliefert.\\n\\nHierbei soll der `POST`-Endpunkt `/task` mit einem Parameter `description` aufgerufen werden k\xf6nnen.\\nM\xf6gliche Requests sehen dann etwa folgenderma\xdfen aus:\\n\\n```\\nGET http://localhost:8080/tasks\\nPOST http://localhost:8080/tasks?description=Some%20Task\\nPOST http://localhost:8080/tasks/toggle-completion/69676cbb-430c-4be8-a3f2-f15cf9e976c3\\n```\\n\\nAu\xdferdem wollen wir nat\xfcrlich auch mit fehlerhaften Benutzereingaben (wie etwa leerer `description` oder unbekannter\\n`id`) umgehen k\xf6nnen und werden dazu eine sogenannte Antikorruptionsschicht zwischen unsere Kernlogik und den\\nREST-Adapter schalten. In einem ersten Schritt wollen wir uns aber erst einmal wieder mit Datenmodellen befassen.\\n\\n:::info\\n\\nIhr findet den aktuellen Stand des Projekts sowie die \xc4nderungen auch aus diesem Teil\\nauf [GitHub](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post3).\\n\\n:::\\n\\n## Tasks mittels eines dedizierten Modells serialisierbar machen\\n\\nAls wir unser Dom\xe4nenobjekt `Task` modelliert haben, haben wir uns bewusst *nicht* mit technischen Belangen\\nauseinandergesetzt, sondern uns komplett auf die Fachlichkeit fokussiert. Entsprechend ungeeignet ist dieses Modell\\ndaher als Austauschformat. Das ist aber nicht weiter problematisch: Wir definieren uns nun ein\\ndediziertes Transfermodell `TaskDto`, das m\xf6glichst schlank und einfach (de-)serialisierbar sein soll, und\\nkonvertieren dann nach Bedarf zwischen `Task` und `TaskDto` hin und her.\\n\\nDieses Transfermodell ist ein technisches\\nDetail unserer REST-Schnittstelle und wird daher auch Teil unseres **REST-Adapters**, den wir in diesem Abschnitt\\nanlegen.\\nDa nach unseren Architekturregeln keine andere Schicht und auch kein anderer Adapter auf diesen REST-Adapter\\nzugreifen darf, ist hierdurch sichergestellt, dass wir das Transfermodell `TaskDto` einzig lokal in diesem\\nAdapter verwenden und es sich nicht durch den Rest unserer Codebasis verbreiten wird.\\n\\nDie Implementierung ist denkbar einfach gehalten:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.adapter.rest.model;\\n\\npublic record TaskDto(String id, String description, String state, String completionTime) {}\\n```\\n\\nStatt eines Summentyps verwenden wir jetzt einen Produkttyp mit dem zus\xe4tzlichen Feld `state` als Diskriminator.\\nAu\xdferdem verwenden wir simple, serialisierbare Typen f\xfcr alle Eigenschaften. Hierdurch gehen uns nat\xfcrlich einige\\nGarantien verloren, daf\xfcr erhalten wir eine flache, serialisierbare Struktur.\\n\\nUm mit dem neu erzeugten Modell `TaskDto` arbeiten zu k\xf6nnen, brauchen wir noch eine M\xf6glichkeit einen `Task`\\nin ein `TaskDto` umzuwandeln. Dazu bauen wir uns einen Mapper mit einer entsprechenden Methode\\n`TaskDto toDto(Task model)`. In dieser werden wir wieder *Pattern Matching* verwenden mit der Konvention, unbenutzte\\nParameter mit einem Unterstrich zu kennzeichnen:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.adapter.rest.mapper;\\n\\nimport ...; // Omitted for clarity\\n\\n@Component\\npublic class RestApiMapper {\\n\\n  public TaskDto toDto(Task model) {\\n    return new TaskDto(\\n            model.id().toString(),\\n            model.description(),\\n            switch (model) {\\n              case OpenTask __ -> \\"open\\";\\n              case CompletedTask __ -> \\"completed\\";\\n            },\\n            switch (model) {\\n              case OpenTask __ -> null;\\n              case CompletedTask t -> t.completionTime().toString();\\n            }\\n    );\\n  }\\n}\\n```\\n\\n## Anlegen eines REST-Controllers\\n\\nNachdem wir uns \xfcber die Datenstrukturen im Klaren sind, k\xf6nnen wir jetzt zur Implementierung der Endpunkte \xfcbergehen.\\nDazu starten wir mit einem Controller, der Zugriff auf unseren Service sowie auf den neu angelegten Mapper haben wird:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.adapter.rest.controller;\\n\\nimport ...; // Omitted for clarity\\n\\n@RestController\\nclass RestApiController {\\n\\n  private final RestApiMapper restApiMapper;\\n  private final TaskService taskService;\\n\\n  RestApiController(RestApiMapper restApiMapper, TaskService taskService) {\\n    this.restApiMapper = restApiMapper;\\n    this.taskService = taskService;\\n  }\\n}\\n```\\n\\nWir wollen uns in einem ersten Schritt um den **`GET`-Endpunkt** k\xfcmmern, der alle existierenden Tasks zur\xfcckliefern\\nsoll.\\nDazu rufen wir die entsprechende Methode in unserem Service auf, wandeln die Resultate mittels unseres Mappers in\\nDtos um und verpacken das Ergebnis schlie\xdflich in einer `ResponseEntity`. Die Methode annotieren wir schlie\xdflich\\nnoch mit `@GetMapping`, alles Weitere erledigt Spring dann automatisch im Hintergrund.\\n\\n```java\\n@GetMapping(value = \\"/tasks\\", produces = MediaType.APPLICATION_JSON_VALUE)\\nResponseEntity<List<TaskDto>> getAllTasks() {\\n  return createOkResponse(taskService.getAllTasks().stream().map(restApiMapper::toDto).toList());\\n}\\n\\nprivate static <T> ResponseEntity<T> createOkResponse(T value) {\\n  return new ResponseEntity<>(value, HttpStatus.OK);\\n}\\n```\\n\\nF\xfcr den **Endpunkt zum Anlegen eines neuen Tasks** gehen wir v\xf6llig analog vor, nur dass wir hier noch einen Parameter\\nzu\\nber\xfccksichtigen haben:\\n\\n```java\\n@PostMapping(value = \\"/tasks\\", produces = MediaType.APPLICATION_JSON_VALUE)\\nResponseEntity<?> createTask(@RequestParam String description) {\\n  return createOkResponse(restApiMapper.toDto(taskService.createTask(description)));\\n}\\n```\\n\\nSchlie\xdflich fehlt uns noch der **Endpunkt zum Umschalten des Zustands eines existierenden Tasks.** Auch hier verfolgen\\nwir wieder das Schema, die entsprechende Logik im Service aufzurufen und das Resultat umzuwandeln, m\xfcssen jedoch\\nauch beachten, dass wir diesmal erst unseren `id` Parameter von `String` zu `UUID` konvertieren m\xfcssen und wir\\nau\xdferdem mit der Situation, dass es keinen Task mit der angegebenen ID gibt, umgehen k\xf6nnen m\xfcssen. In diesem Fall\\nwerden wir schlicht mit dem Status `400 Bad Request` antworten.\\n\\nDamit gestaltet sich die Methode folgenderma\xdfen:\\n\\n```java\\n@PostMapping(value = \\"/tasks/toggle-completion/{id}\\", produces = MediaType.APPLICATION_JSON_VALUE)\\nResponseEntity<?> toggleCompletionState(@PathVariable String id) {\\n  return taskService\\n          .toggleCompletionState(UUID.fromString(id))\\n          .map(restApiMapper::toDto)\\n          .map(RestApiController::createOkResponse)\\n          .orElseGet(RestApiController::createBadRequestResponse);\\n}\\n\\nprivate static <T> ResponseEntity<T> createBadRequestResponse() {\\n  return new ResponseEntity<>(HttpStatus.BAD_REQUEST);\\n}\\n```\\n\\nHiermit haben wir nun eine voll funktionsf\xe4hige Anwendung!\\n\\nIm [GitHub Repository](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post3) findet ihr\\nau\xdferdem noch\\n**Unit- und Integrationstests** f\xfcr unseren neuen Controller (`RestApiControllerTest`\\nund `RestApiControllerIntegrationTest`).\\n\\nZus\xe4tzlich ist es uns jetzt auch m\xf6glich, **End-To-End-Tests**, die einen vollst\xe4ndigen Anwendungskontext hochfahren,\\neine\\nFolge von REST-Requests absetzen und von der Anwendung entsprechende Antworten erwarten, zu schreiben. Diese m\xf6chte\\nich an dieser Stelle kurz demonstrieren, da sie auch demonstrieren, wie unsere Anwendung zu verwenden ist:\\n\\n```java\\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\\nclass HexagonalToDoListApplicationEndToEndTests {\\n\\n  @Autowired\\n  private TestRestTemplate restTemplate;\\n\\n  @Test\\n  void returnsEmptyListIfNoTasksHaveBeenCreated() {\\n    var result = getAllTasks();\\n\\n    assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);\\n    assertThat(result.getBody()).isEmpty();\\n  }\\n\\n  @Test\\n  void creatingTasksIsPossibleAndCreatedTasksAreReturnedFromGetAll() {\\n    List<String> descriptions = List.of(\\"Some description\\", \\"Some other description\\");\\n\\n    descriptions.forEach(this::createTask);\\n\\n    var result = getAllTasks();\\n\\n    assertThat(result.getStatusCode()).isEqualTo(HttpStatus.OK);\\n    assertThat(result.getBody())\\n            .usingRecursiveFieldByFieldElementComparatorIgnoringFields(\\"id\\")\\n            .containsExactlyInAnyOrder(\\n                    new TaskDto(null, \\"Some description\\", \\"open\\", null),\\n                    new TaskDto(null, \\"Some other description\\", \\"open\\", null)\\n            );\\n    assertThat(result.getBody()).extracting(TaskDto::id).extracting(UUID::fromString).doesNotContainNull();\\n  }\\n\\n  @Test\\n  void completionStateOfTasksCanBeToggledAndTogglingOnlyChangesStateAndCompletionTime() {\\n    var createdTask = createTask(\\"Some description\\").getBody();\\n    assertThat(createdTask.state()).isEqualTo(\\"open\\");\\n\\n    var id = createdTask.id();\\n\\n    var toggledTask = toggleTask(id).getBody();\\n    assertThat(toggledTask)\\n            .usingRecursiveComparison()\\n            .ignoringFields(\\"state\\", \\"completionTime\\")\\n            .isEqualTo(createdTask);\\n    assertThat(toggledTask.state()).isEqualTo(\\"completed\\");\\n    assertThat(toggledTask.completionTime()).isNotNull();\\n\\n    var toggledTwiceTask = toggleTask(id).getBody();\\n    assertThat(toggledTwiceTask).isEqualTo(createdTask);\\n\\n    var toggledThriceTask = toggleTask(id).getBody();\\n    assertThat(toggledThriceTask)\\n            .usingRecursiveComparison()\\n            .ignoringFields(\\"completionTime\\")\\n            .isEqualTo(toggledTask);\\n    assertThat(LocalDateTime.parse(toggledThriceTask.completionTime()))\\n            .isAfter(LocalDateTime.parse(toggledTask.completionTime()));\\n  }\\n\\n  private ResponseEntity<List<TaskDto>> getAllTasks() {\\n    return restTemplate.exchange(\\"/tasks\\", HttpMethod.GET, null, new ParameterizedTypeReference<>() {});\\n  }\\n\\n  private ResponseEntity<TaskDto> createTask(String description) {\\n    return restTemplate.postForEntity(\\n            UriComponentsBuilder.fromPath(\\"/tasks\\").queryParam(\\"description\\", description).build().toUri(),\\n            null,\\n            TaskDto.class\\n    );\\n  }\\n\\n  private ResponseEntity<TaskDto> toggleTask(String id) {\\n    return restTemplate.postForEntity(\\"/tasks/toggle-completion/{id}\\", null, TaskDto.class, Map.of(\\"id\\", id));\\n  }\\n```\\n\\nWas uns jetzt noch fehlt, ist die eingangs erw\xe4hnte Antikorruptionsschicht. Diese soll verhindern, dass Tasks mit leerer\\nBeschreibung angelegt werden (was derzeit m\xf6glich w\xe4re, aber unserer Fachlichkeit widerspricht) oder aber, dass der\\nBenutzer versucht, den *Toggle*-Endpunkt mit einem `id`-Wert aufzurufen, der keine g\xfcltige UUID darstellt (was\\nderzeit zu einer Exception f\xfchren w\xfcrde).\\n\\n## Datenintegrit\xe4t durch eine Antikorruptionsschicht\\n\\nDer sicherlich g\xe4ngigste Weg im Spring-Umfeld zur Sicherstellung der Datenintegrit\xe4t an Endpunkten ist die Verwendung\\nvon *Bean Validation*. Diese erf\xfcllt den Zweck vollkommen und ist f\xfcr Produktivprojekte auch klar zu empfehlen. Da\\ndieser\\nMechanismus aber weitestgehend auf der Verwendung von Annotationen basiert, m\xf6chte ich hier zur besseren\\nNachvollziehbarkeit stattdessen eine manuelle Implementierung vornehmen.\\n\\nIn der Theorie siedelt sich eine solche Antikorruptionsschicht zwischen Adapter und Kernlogik an und soll daf\xfcr sorgen,\\ndass die Kernlogik stets nur mit validen Daten aufgerufen wird. Das hat den immensen Vorteil, dass wir uns dann dort\\nniemals Gedanken um invalide Zust\xe4nde machen m\xfcssen und daher dort auch nicht *defensiv* programmieren m\xfcssen. Eine\\nsolche\\nSchicht macht daher nicht nur an der Grenze zu einem REST-Adapter Sinn, sondern \xfcberall, wo potenziell invalide\\nDatens\xe4tze von der Au\xdfenwelt an uns herangetragen werden (wie etwa eine Datenbank, \xfcber die wir nicht die alleinige\\nKontrolle haben, Message-Queues, Lesen vom Dateisystem).\\n\\n<figure style={{textAlign: \'center\'}}>\\n    <img src={antiCorruptionLayer} alt=\\"missing\\" height={500}/>\\n    <figcaption>Antikorruptionsschicht: Zwischen Adapter und Kernlogik</figcaption>\\n</figure>\\n\\nPraktisch wollen wir diese Validierung der Daten daher im entsprechenden Adapter unterbringen, da diese nur dort\\nSinn macht. Denn in anderen Adaptern haben wir vermutlich andere Austauschformate und ben\xf6tigen daher andere\\nValidierungen.\\n\\nDazu werden wir uns nun einen `RestApiValidator` unterhalb des REST-Adapter-Pakets in\\n`de.colenet.hexagonal.todo.list.adapter.rest.validator` anlegen. Dieser soll uns zwei Methoden - `validateId`\\nund `validateDescription` - anbieten, die jeweils einen unvalidierten `String` entgegennehmen und uns im Erfolgsfall\\neine\\nvalidierte `UUID`, respektive einen validierten `String`, zur\xfcckliefern.\\n\\nHierzu verwenden wir\\ndie [Validation API von Vavr](https://docs.vavr.io/#_validation), die es uns auf elegante Art und Weise erlaubt,\\nsolche Validierungen inklusive der Ber\xfccksichtigung von Fehlern zu implementieren. Insbesondere erlaubt uns diese API,\\nmehrere\\nfehlgeschlagene Validierungen zu kombinieren und so dem Benutzer direkt R\xfcckmeldung \xfcber jeglichen invaliden Input\\nzur\xfcckzumelden (hierbei sprechen wir von einem *Fail-Slow* Ansatz). Hierzu entschlie\xdfen wir uns, da wir im n\xe4chsten\\nTeil der Serie unser Dom\xe4nenmodell erweitern wollen und wir dann f\xfcr den Endpunkt zum Anlegen eines neuen Tasks\\nmehrere Parameter entgegennehmen werden.\\nIm Gegensatz zum *Fail-Slow* Ansatz w\xfcrde die - im Java-Umfeld g\xe4ngige - Methode, bei fehlgeschlagener Validierung\\neine Exception zu werfen, nur den ersten Validierungsfehler zur\xfcckmelden (ein sogenannter *Fail-Fast* Ansatz).\\n\\n:::note[Randbemerkung]\\n\\nBei dem von uns gew\xe4hlten *Fail-Slow*-Ansatz handelt es sich um eine in der funktionalen Programmierung\\ng\xe4ngigen Technik. Das Konzept ist in diesem Kontext als *Validierung mittels applikativer Funktoren* gel\xe4ufig.\\n\\n:::\\n\\nKommen wir nun also zur Umsetzung des Validators. Zur Validierung der `description` wollen wir nur\\n\xfcberpr\xfcfen, dass sie nicht leer ist, und ansonsten eine entsprechende Fehlermeldung generieren:\\n\\n```java\\npublic Validation<String, String> validateDescription(String description) {\\n  if (!StringUtils.hasText(description)) {\\n    return Validation.invalid(\\"Description is mandatory\\");\\n  }\\n\\n  return Validation.valid(description);\\n}\\n```\\n\\nDer R\xfcckgabetyp `Validation` ist hierbei ein von Vavr bereitgestelltes Interface, welches als ersten Typparameter\\nden Typ des Fehlerobjekts und als zweiten Typparameter den Typ des Erfolgsobjekts erwartet. F\xfcr die Validierung\\nunserer ID wird der zweite Typparameter daher `UUID` sein und im n\xe4chsten Post werden wir auch eine Liste von\\nStrings als Fehlertyp sehen.\\n\\nDie Validierung der ID folgt demselben Schema, hier m\xfcssen wir jedoch zus\xe4tzlich pr\xfcfen, dass der Eingabewert eine\\nvalide UUID darstellt.\\n\\n```java\\npublic Validation<String, UUID> validateId(String id) {\\n  if (!StringUtils.hasText(id)) {\\n    return Validation.invalid(\\"ID is mandatory\\");\\n  }\\n\\n  return Try.of(() -> UUID.fromString(id)).toValidation(__ -> \\"Not a valid UUID: \\" + id);\\n}\\n```\\n\\nMittels `Try` fangen wir hier die von `UUID::fromString` im Fehlerfall geworfene Exception und wandeln sie in\\nein `Validation`-Objekt mit entsprechender Fehlermeldung um.\\n\\nNun m\xfcssen wir diese Validierungen nur noch in unserem `RestApiController` jeweils vor dem Aufruf der Kernlogik\\nunterbringen. Dazu injizieren wir eine Instanz `restApiValidator` des gerade entworfenen Validators in den Controller\\nund erweitern unsere Methoden dort folgenderma\xdfen:\\n\\n```java\\n@PostMapping(value = \\"/tasks\\", produces = MediaType.APPLICATION_JSON_VALUE)\\nResponseEntity<?> createTask(@RequestParam String description) {\\n  return restApiValidator\\n          .validateDescription(description)\\n          .map(taskService::createTask)\\n          .map(restApiMapper::toDto)\\n          .fold(RestApiController::createBadRequestResponse, RestApiController::createOkResponse);\\n}\\n\\n@PostMapping(value = \\"/tasks/toggle-completion/{id}\\", produces = MediaType.APPLICATION_JSON_VALUE)\\nResponseEntity<?> toggleCompletionState(@PathVariable String id) {\\n  return restApiValidator\\n          .validateId(id)\\n          .map(taskService::toggleCompletionState)\\n          .fold(\\n                  RestApiController::createBadRequestResponse,\\n                  toggledTask ->\\n                          toggledTask\\n                                  .map(restApiMapper::toDto)\\n                                  .<ResponseEntity<?>>map(RestApiController::createOkResponse)\\n                                  .orElseGet(() -> createBadRequestResponse(\\"No task found for id: \\" + id))\\n          );\\n}\\n\\nprivate static ResponseEntity<String> createBadRequestResponse(String message) {\\n  return new ResponseEntity<>(message, HttpStatus.BAD_REQUEST);\\n}\\n```\\n\\nNat\xfcrlich haben wir im Repository auch Unittests f\xfcr den Validator mit aufgenommen und unsere bestehenden Tests\\nerweitert.\\n\\n**Damit ist der erste Wurf unserer Anwendung komplett.**\\n\\nProbiert sie doch gerne mal aus: Legt Tasks an, lasst euch diese anzeigen, vervollst\xe4ndigt sie und setzt auch mal\\nabsichtlich Requests mit invaliden Daten ab, wie etwa:\\n\\n```\\nPOST http://localhost:8080/tasks?description=%20\\nPOST http://localhost:8080/tasks/toggle-completion/not-a-valid-uuid\\n```\\n\\n## Ausblick\\n\\nIm kommenden Teil wollen wir uns anschauen, wie sich eine Anpassung am Dom\xe4nenmodell auf die Anwendung auswirkt. Dazu\\nwerden wir unseren Tasks ein F\xe4lligkeitsdatum hinzuf\xfcgen. Dieses werden wir dann auch nutzen, um die bisher noch\\nunber\xfchrte Applikationsschicht mit Leben zu f\xfcllen, indem wir uns einen geplanten Auftrag anlegen, der uns regelm\xe4\xdfig\\n\xfcber f\xe4llige Tasks benachrichtigt. Au\xdferdem wollen wir die M\xf6glichkeit bieten, beim Anwendungsstart automatisch einige\\nBeispieltasks zu erzeugen."},{"id":"hexagonal-architecture-java-spring-boot-part-2","metadata":{"permalink":"/hexagonal-architecture-java-spring-boot-part-2","source":"@site/blog/hexagonal-architecture/part2/part2.mdx","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 2: Modellierung, Kernlogik und In-Memory Cache","description":"banner","date":"2023-11-09T00:00:00.000Z","formattedDate":"9. November 2023","tags":[{"label":"Domain-driven Design","permalink":"/tags/domain-driven-design"},{"label":"Hexagonale Architektur","permalink":"/tags/hexagonale-architektur"},{"label":"Softwarearchitektur","permalink":"/tags/softwarearchitektur"},{"label":"Softwareentwicklung","permalink":"/tags/softwareentwicklung"}],"readingTime":8.14,"hasTruncateMarker":true,"authors":[{"name":"Ricardo Schnur","title":"Software Developer @ Colenet GmbH","url":"https://github.com/ricardo-schnur","imageURL":"img/profile.png","key":"ricardo"}],"frontMatter":{"slug":"hexagonal-architecture-java-spring-boot-part-2","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 2: Modellierung, Kernlogik und In-Memory Cache","authors":"ricardo","tags":["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],"date":"2023-11-09T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring Boot Projekt \u2013 Teil 3: REST-Schnittstelle mit Antikorruptionsschicht","permalink":"/hexagonal-architecture-java-spring-boot-part-3"},"nextItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 1: Projektbeschreibung, Setup und automatische Architekturtests","permalink":"/hexagonal-architecture-java-spring-boot-part-1"}},"content":"![banner](./banner.webp)\\n\\n> Um zu verstehen, wie hexagonale Architektur die Art und Weise, Software zu entwickeln ver\xe4ndert und was dabei\\n> die Vorteile sind, f\xfchrt Ricardo uns Schritt f\xfcr Schritt durch die Entwicklung einer To-Do-Listen-Anwendung.\\n> In dieser Folge startet nun die eigentliche Entwicklung mit der Modellierung der Dom\xe4ne, der Kernlogik der\\n> Anwendung sowie der Datenhaltung in einem Cache.\\n\\n{/* truncate */}\\n\\n<head>\\n    <link rel=\\"canonical\\"\\n          href=\\"https://www.colenet.de/blog/development/hexagonale-architektur-modellierung-kernlogik-und-in-memory-cache/\\"/>\\n</head>\\n\\n## Das Vorhaben: Hexagonale Architektur in der Praxis verstehen\\n\\nDiese Artikel-Reihe ist der hexagonalen Architektur gewidmet: Wir m\xf6chten ihre Grundprinzipien verstehen und dazu in der\\nPraxis erleben. Wir werden uns anschauen, wie sich eine hexagonale Architektur in einer typischen Webanwendung praktisch\\nrealisieren l\xe4sst. Dazu werden wir Schritt f\xfcr Schritt eine kleine **To-do-Listen-Anwendung** entwickeln, die es\\nerm\xf6glichen\\nsoll, Tasks anzulegen, angelegte Tasks anzuzeigen und Tasks als erledigt zu markieren. Die Anwendung wird \xfcber eine\\nREST-Schnittstelle bedienbar sein und die Tasks werden konfigurierbar entweder In-Memory oder persistent in einer echten\\nMongoDB verwaltet.\\n\\n[Im ersten Teil dieser Serie](https://ricardo-schnur.github.io/hexagonal-architecture-java-spring-boot-part-1) haben wir\\nein frisches Java/Spring-Boot-Projekt aufgesetzt und konfiguriert. Wir haben uns\\n\xfcberlegt, wie wir uns die Architektur der Anwendung und ihre Umsetzung vorstellen und diese Vorstellung mittels ArchUnit\\nin einem automatisierten Architekturtest festgehalten.\\n\\nNun wollen wir mit der tats\xe4chlichen Entwicklung starten und uns in diesem Teil der Serie mit der Modellierung der\\nDom\xe4ne, der Kernlogik der Anwendung sowie dem Bereitstellen einer Schnittstelle \u2013 um die Anwendung auch wirklich\\nverwenden zu k\xf6nnen \u2013 befassen.\\n\\n:::info\\n\\nDen Code findet ihr auch zu diesem Teil zum Nachvollziehen\\nauf [GitHub](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post2).\\n\\n:::\\n\\n## Das Dom\xe4nenmodell\\n\\nF\xfcr unsere To-do-Listen-Anwendung soll es ein einziges Dom\xe4nenobjekt geben, n\xe4mlich einen *Task*. Dieser soll ganz\\ngrundlegende Informationen enthalten: Eine *Beschreibung*, den *Zustand*, ob der Task noch *offen*, oder er bereits\\n*erledigt*\\nist und, falls erledigt, den *Abschlusszeitpunkt*. Au\xdferdem wollen wir den Objekten noch eine ID zuweisen, um sie\\neindeutig identifizieren zu k\xf6nnen (und zum Beispiel zwei offene Tasks mit gleicher Beschreibung voneinander\\nunterscheiden zu k\xf6nnen).\\n\\nBei der Realisierung dieses Modells im Code wollen wir uns dabei so genau wie m\xf6glich an den Dom\xe4nenanforderungen\\norientieren. Insbesondere wollen wir uns hier nicht von infrastrukturellen/technischen Gedanken wie *L\xe4sst sich das\\nModellobjekt serialisieren?, Ist das Design geeignet f\xfcr eine relationale Datenbank?* oder \xc4hnlichen beeinflussen\\nlassen.\\nF\xfcr solche Belange werden wir stattdessen sp\xe4ter dedizierte, optimierte Datenstrukturen anlegen und im entsprechenden\\nKontext (lokal!) verwenden. Im Herzen unserer Anwendung wollen wir hingegen so nahe an der Fachdom\xe4ne sein wie m\xf6glich.\\n\\nWir wollen also **einerseits die Typen unserer Eigenschaften so spezifisch und aussagekr\xe4ftig wie m\xf6glich w\xe4hlen** \u2013\\netwa\\nsoll unsere ID vom Typ UUID und nicht etwa nur ein String oder int sein \u2013 und **andererseits wollen wir es unm\xf6glich\\n(bzw. in der Praxis zumindest m\xf6glichst schwierig) machen, in der Dom\xe4ne *unm\xf6gliche Zust\xe4nde* \xfcberhaupt darstellen\\nzu k\xf6nnen** (und damit Fehler kategorisch ausschlie\xdfen).\\n\\nDer zweite Punkt bedeutet f\xfcr uns an dieser Stelle konkret, dass wir nicht etwa ein einziges Task-Objekt in der Form\\n\\n```java\\nenum TaskState {\\n    OPEN, CLOSED\\n}\\n\\nrecord Task(UUID id, String description, TaskState state, LocalDateTime completionTime) {}\\n```\\n\\ndarstellen m\xf6chten, denn sonst w\xfcrde uns nichts davon abhalten, einen offenen Task mit gesetzter Abschlusszeit\\nanzulegen.\\n\\nStattdessen wollen wir strikt zwischen offenen und geschlossenen Tasks unterscheiden und nur geschlossenen Tasks\\ndie Eigenschaft `completionTime` zuzuordnen. In der Theorie sprechen wir hierbei von einem sogenannten **Summentyp**,\\nwohingegen die ungew\xfcnschte Darstellung oben einen **Produkttyp** darstellt. Zur Umsetzung k\xf6nnen wir dazu das\\nk\xfcrzlich mit Java 17 eingef\xfchrte `sealed` Schl\xfcsselwort verwenden:\\n\\n```java\\npublic sealed interface Task {\\n    UUID id();\\n\\n    String description();\\n\\n    record OpenTask(UUID id, String description) implements Task {}\\n\\n    record CompletedTask(UUID id, String description, LocalDateTime completionTime) implements Task {}\\n}\\n```\\n\\nDieses Interface legen wir dabei entsprechend unserer \xdcberlegungen im vorangegangen Post im Paket\\n`de.colenet.hexagonal.todo.list.domain.model.task` ab. Durch das Versiegeln des Interfaces `Task` stellen wir sicher,\\ndass dieses ausschlie\xdflich von den beiden im Rumpf\\ndefinierten Klassen `OpenTask` und `CompletedTask` implementiert werden kann.\\nDass wir die geteilten Eigenschaften `id` und `description` zus\xe4tzlich zu den Klasseneigenschaften auch noch im\\nInterface direkt deklarieren, ist strikt optional und hat rein ergonomische Gr\xfcnde: An vielen Stellen der Anwendung\\nwird es uns nicht interessieren, ob ein konkreter Task noch offen oder schon abgeschlossen ist, und hierdurch ersparen\\nwir uns an diesen Stellen Fallunterscheidungen.\\n\\nWollten wir in unserer Modellierung noch genauer sein, so k\xf6nnten wir uns f\xfcr unsere `description` auch noch einen\\nDatentyp `NonEmptyString` mit entsprechender Absicherung der geforderten *nicht-leer* Bedingung im Konstruktor anlegen,\\nder Einfachheit halber sehen wir davon an dieser Stelle aber ab.\\n\\nGewappnet mit dieser Darstellung unseres Dom\xe4nenmodells wollen wir uns nun der Kernfunktionalit\xe4t unserer Anwendung\\nzuwenden: dem Erzeugen, Abschlie\xdfen und Ausgeben von solchen Tasks.\\n\\nIn einem kommenden Teil der Serie werden wir uns au\xdferdem anschauen, wie wir dieses Modell erweitern k\xf6nnen, und welche\\nAuswirkungen das auf unsere (bis dahin schon funktionale) Anwendung haben wird.\\n\\n## Die Kernfunktionalit\xe4t: *Domain Services*\\n\\nNun wollen wir uns die gew\xfcnschte Funktionalit\xe4t auf *fachlicher* Ebene anschauen. Dabei werden wir schnell bemerken,\\ndass\\nwir uns um die \\"eigentliche\\" Arbeit an dieser Stelle nur wenige Gedanken machen m\xfcssen und diese stattdessen einfach in\\ndie Zukunft verschieben k\xf6nnen (n\xe4mlich in den n\xe4chsten Abschnitt, in dem wir uns mit der Datenhaltung in einem Cache\\nbefassen werden).\\n\\nIm Grunde genommen wollen wir drei Grundfunktionalit\xe4ten:\\n\\n1. Wir wollen einen neuen Task anlegen k\xf6nnen (der im Zustand *offen* sein soll).\\n2. Wir wollen alle existierenden Tasks abrufen k\xf6nnen.\\n3. Wir wollen den Zustand eines Tasks umschalten k\xf6nnen.\\n\\nDas f\xfchrt uns zu folgenden Methodensignaturen, die wir mit Leben f\xfcllen wollen:\\n\\n```java\\nTask createTask(String description);\\n\\nList<Task> getAllTasks();\\n\\nOptional<Task> toggleCompletionState(UUID id);\\n```\\n\\nHierbei machen wir mit dem R\xfcckgabetypen `Optional<Task>` in der letzten Methode deutlich, dass diese fehlschlagen kann,\\nwenn kein Task mit der gegebenen ID existiert.\\n\\nWie bereits angedeutet, wollen wir einen Gro\xdfteil der Implementierung in unsere Persistenzschicht\\n(oder genauer, den Persistenz*adapter*) auslagern. Im Sinne unserer hexagonalen Architektur, die auch als *Ports und\\nAdapter* bekannt ist, legen wir uns dazu einen Port (In der Form eines Interfaces) an, in dem wir uns *w\xfcnschen*, was\\nein eventueller Persistenzadapter doch bitte f\xfcr uns erledigen soll:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.domain.service.task;\\n\\nimport ...; // Omitted for clarity\\n\\npublic interface TaskRepository {\\n    Task save(Task task);\\n\\n    Optional<Task> find(UUID id);\\n\\n    List<Task> getAll();\\n}\\n```\\n\\nSolche Ports z\xe4hlen dabei zur Gesch\xe4ftslogik und liegen damit auch in unserem *Domain Services*-Paket.\\nDie Ausimplementierungen der Ports befinden sich hingegen in den entsprechenden Adaptern.\\n\\nMithilfe dieses Ports k\xf6nnen wir nun unsere eigentliche Serviceklasse anlegen:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.domain.service.task;\\n\\nimport ...; // Omitted for clarity\\n\\n@Service\\npublic class TaskService {\\n\\n    private final TaskRepository taskRepository;\\n\\n    public TaskService(TaskRepository taskRepository) {\\n        this.taskRepository = taskRepository;\\n    }\\n\\n    public Task createTask(String description) {\\n        // TODO\\n    }\\n\\n    public List<Task> getAllTasks() {\\n        // TODO\\n    }\\n\\n    public Optional<Task> toggleCompletionState(UUID id) {\\n        // TODO\\n    }\\n}\\n```\\n\\nDie Ausimplementierung der drei Methoden gestaltet sich jetzt sehr einfach. Zum Erzeugen eines Tasks wollen wir einfach\\neinen neuen, offenen Task mit zuf\xe4llig generierter ID \xfcber den Port anlegen:\\n\\n```java\\npublic Task createTask(String description) {\\n    return taskRepository.save(new OpenTask(UUID.randomUUID(), description));\\n}\\n```\\n\\nUnd das Laden k\xf6nnen wir vollst\xe4ndig an den Port delegieren:\\n\\n```java\\npublic List<Task> getAllTasks() {\\n    return taskRepository.getAll();\\n}\\n```\\n\\nUm den Zustand von Tasks abzu\xe4ndern, nutzen wir das mit Java 21 neu eingef\xfchrte\\nFeature [Pattern Matching for switch](https://openjdk.org/jeps/433) in Kombination mit *Switch Expressions*.\\nAu\xdferdem nutzen wir auch hier wieder den Port:\\n\\n```java\\npublic Optional<Task> toggleCompletionState(UUID id) {\\n    return taskRepository.find(id).map(this::withToggledCompletionState).map(taskRepository::save);\\n}\\n\\nprivate Task withToggledCompletionState(Task task) {\\n    return switch (task) {\\n        case OpenTask t -> new CompletedTask(t.id(), t.description(), LocalDateTime.now(clock));\\n        case CompletedTask t -> new OpenTask(t.id(), t.description());\\n    };\\n}\\n```\\n\\nHierbei verwenden wir ein `Clock clock` Objekt, welches wir analog zum Repository \xfcber den Konstruktor injizieren,\\num unseren Code testbar zu halten. Die entsprechende Konfiguration daf\xfcr legen wir in einem technischen Modul an:\\n\\n```java\\npackage de.colenet.hexagonal.todo.list.domain.service.technical.clock;\\n\\nimport ...; // Omitted for clarity\\n\\n@Configuration\\nclass ClockConfiguration {\\n\\n    @Bean\\n    public Clock clock() {\\n        return Clock.systemDefaultZone();\\n    }\\n}\\n```\\n\\n**Testbarkeit ist \xfcbrigens einer der gro\xdfen Vorteile, die uns die gew\xe4hlte Architektur liefert.** Obwohl wir noch keine\\nImplementierung f\xfcr den Port haben, k\xf6nnen wir an dieser Stelle bereits Unittests f\xfcr unseren Service schreiben, indem\\nwir den Port mocken. Das f\xfchrt auch automatisch dazu, dass wir uns in diesen Tests rein auf die Fachlichkeit\\nkonzentrieren. Das Zusammenspiel der Komponenten werden wir sp\xe4ter mittels Integrations- und End-To-End-Tests\\n\xfcberpr\xfcfen. Da das Testen nicht der Fokus dieser Serie sein soll, werde ich hier nicht tiefer auf die Unittests\\neingehen. Gerne seid ihr aber dazu eingeladen, euch im\\nbegleitenden [GitHub Repository](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post2) die\\nKlasse `TaskServiceTest` anzuschauen.\\n\\nDamit steht der Kern unserer Anwendung bereits! Solltet ihr die Anwendung im aktuellen Zustand starten wollen,\\nwerdet ihr aber noch keinen Erfolg haben, da derzeit keine Implementierung f\xfcr `TaskRepository` existiert.\\nIhr k\xf6nnt euch nat\xfcrlich f\xfcr den Moment eine Dummy-Implementierung anlegen - oder ihr wartet, bis wir uns gleich\\ndem Cache-Adapter zuwenden.\\n\\n## In-Memory Cache\\n\\nZum Abschluss wollen wir eine konkrete Implementierung f\xfcr unseren Port `TaskRepository` in Form eines\\nsimplen Caches anlegen. Wie bereits in unserem Architekturtest verankert, wollen wir diese Implementierung im\\nAdapter-Paket `de.colenet.hexagonal.todo.list.adapter.cache` ablegen. Wir werden an dieser Stelle von jeglichen\\nOptimierungen Abstand halten und stattdessen zu Demonstrationszwecken m\xf6glichst einfachen, wenn auch nicht unbedingt\\nproduktionsreifen, Code schreiben. Daher entscheiden wir uns dazu, den Adapter als simplen Wrapper um eine `Map`\\nzu realisieren. Die komplette Implementierung l\xe4sst sich damit direkt niederschreiben:\\n\\n```java\\n@Repository\\nclass TaskCache implements TaskRepository {\\n\\n    // LinkedHashMap keeps insertion order\\n    private final Map<UUID, Task> tasks = new LinkedHashMap<>();\\n\\n    @Override\\n    public Task save(Task task) {\\n        tasks.put(task.id(), task);\\n        return task;\\n    }\\n\\n    @Override\\n    public Optional<Task> find(UUID id) {\\n        return Optional.ofNullable(tasks.get(id));\\n    }\\n\\n    @Override\\n    public List<Task> getAll() {\\n        return List.copyOf(tasks.values());\\n    }\\n}\\n```\\n\\nAuch hier m\xf6chte ich wieder anmerken, dass wir die Implementierung losgel\xf6st von jeglicher Abh\xe4ngigkeit ganz einfach\\nUnit-testen k\xf6nnen und auf `TaskServiceTest` im\\n[GitHub Repository](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post2) hinweisen.\\n\\n## Ausblick\\n\\n**Wir haben bisher eine simple, aber schon funktionale und lauff\xe4hige Anwendung entwickelt.** Um diese jedoch wirklich\\nnutzen zu k\xf6nnen, fehlt uns noch eine Steuerungsm\xf6glichkeit. Daher werden wir die Anwendung im n\xe4chsten Teil der\\nReihe um eine REST-Schnittstelle erweitern, die uns dann die tats\xe4chliche Nutzung erm\xf6glicht."},{"id":"hexagonal-architecture-java-spring-boot-part-1","metadata":{"permalink":"/hexagonal-architecture-java-spring-boot-part-1","source":"@site/blog/hexagonal-architecture/part1/part1.mdx","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 1: Projektbeschreibung, Setup und automatische Architekturtests","description":"banner","date":"2023-10-10T00:00:00.000Z","formattedDate":"10. Oktober 2023","tags":[{"label":"Domain-driven Design","permalink":"/tags/domain-driven-design"},{"label":"Hexagonale Architektur","permalink":"/tags/hexagonale-architektur"},{"label":"Softwarearchitektur","permalink":"/tags/softwarearchitektur"},{"label":"Softwareentwicklung","permalink":"/tags/softwareentwicklung"}],"readingTime":6.815,"hasTruncateMarker":true,"authors":[{"name":"Ricardo Schnur","title":"Software Developer @ Colenet GmbH","url":"https://github.com/ricardo-schnur","imageURL":"img/profile.png","key":"ricardo"}],"frontMatter":{"slug":"hexagonal-architecture-java-spring-boot-part-1","title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 1: Projektbeschreibung, Setup und automatische Architekturtests","authors":"ricardo","tags":["Domain-driven Design","Hexagonale Architektur","Softwarearchitektur","Softwareentwicklung"],"date":"2023-10-10T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Hexagonale Architektur in der Praxis: Umsetzung in einem Java/Spring-Boot-Projekt \u2013 Teil 2: Modellierung, Kernlogik und In-Memory Cache","permalink":"/hexagonal-architecture-java-spring-boot-part-2"}},"content":"![banner](./banner.webp)\\n\\n> In der Softwareentwicklung gibt es eine Architektur, die seit einigen Jahren immer mehr an Bedeutung gewinnt \u2013\\n> die hexagonale Architektur. Ricardo erkl\xe4rt diese Architektur und ihre Grundprinzipien anschaulich und f\xfchrt uns\\n> in 5 Teilen Schritt f\xfcr Schritt durch die konkrete Anwendung.\\n\\n{/* truncate */}\\n\\n<head>\\n    <link rel=\\"canonical\\"\\n          href=\\"https://www.colenet.de/blog/development/hexagonale-architektur-in-der-praxis-umsetzung-in-einem-java-spring-boot-projekt-teil-1/\\"/>\\n</head>\\n\\n\\nimport folderStructureInitializedApplication from \'./folder_structure_initialized_application.png\';\\nimport onionCallHierarchy from \'./onion_call_hierarchy.png\';\\nimport onionLayers from \'./onion_layers.png\';\\nimport onionPackages from \'./onion_packages.png\';\\n\\nIn der Softwareentwicklung gibt es eine Architektur, die seit einigen Jahren immer mehr an Bedeutung gewinnt \u2013 **die hexagonale Architektur**.\\nIch hatte mehrfach die Gelegenheit, diese Architektur in Kundenprojekten zu realisieren und konnte dabei direkt miterleben, wie sie die Art und Weise,\\nwie wir Software entwickeln, ver\xe4ndert.\\n\\nIn dieser Serie werden wir uns diese Architektur genauer anschauen und ihre Grundprinzipien in der Praxis erleben.\\nIhr werdet feststellen, **dass sie die Anforderungen unserer Benutzer in den Vordergrund stellt und uns gleichzeitig erlaubt,\\nden Code auf eine Weise organisieren zu k\xf6nnen, die sowohl robust als auch flexibel ist**. Damit tr\xe4gt sie erheblich zur Wartbarkeit,\\nErweiterbarkeit und Testbarkeit unserer Anwendungen bei.\\n\\nWir werden uns anschauen, wie sich eine hexagonale Architektur in einer typischen Webanwendung praktisch realisieren l\xe4sst.\\nDazu werden wir Schritt f\xfcr Schritt eine kleine **To-do-Listen-Anwendung** entwickeln, die es erm\xf6glichen soll, Tasks anzulegen,\\nTasks anzuzeigen und Tasks als erledigt zu markieren. Die Anwendung wird \xfcber eine REST-Schnittstelle bedienbar sein und die Tasks werden konfigurierbar\\nentweder In-Memory oder persistent in einer echten MongoDB verwaltet.\\n\\nZum Einstieg m\xf6chte ich kurz darauf eingehen, was gemeint ist, wenn wir von einer hexagonalen Architektur sprechen.\\n\\n## Hexagonale Architektur - was ist das \xfcberhaupt?\\n\\nEs handelt sich hierbei um einen Architekturstil, der unter vielen Namen bekannt ist: *hexagonale Architektur*,\\n*Ports und Adapter*, *Zwiebelarchitektur (Onion Architecture)*, *Clean Architecture*\\n\\nAll diese Architekturstile unterscheiden sich im Detail, basieren aber auf denselben Kernideen und Prinzipien.\\nAuf die feinen Unterschiede m\xf6chte ich an dieser Stelle nicht genauer eingehen, sondern verweise auf die zahlreichen,\\nonline verf\xfcgbaren Ressourcen zu diesem Thema, wie etwa den hervorragenden \xdcbersichtsartikel\\nvon [Herberto Gra\xe7a (englisch)](https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/).\\n\\nIn dieser Serie wollen wir die Unterschiede unterschlagen und die Begriffe *hexagonale Architektur* und\\n*Zwiebelarchitektur* synonym verwenden. Wir verstehen darunter eine Anwendungsarchitektur, die den Code in\\nkonzentrischen Schichten (daher der Name *Zwiebel*) organisiert. Hierbei sind nur Abh\xe4ngigkeiten von au\xdfen nach innen\\ngestattet (es d\xfcrfen dabei aber Schichten \xfcbersprungen werden), sodass insbesondere die innerste Schicht keinerlei\\nAbh\xe4ngigkeiten auf den Rest des Codes haben darf. Genauer unterteilen wir unsere Anwendung in die folgenden drei,\\nvon innen nach au\xdfen angeordneten Schichten:\\n\\n1. **Dom\xe4nenschicht**: Beinhaltet die Dom\xe4nenmodelle und die Kerngesch\xe4ftslogik.\\n2. **Anwendungsschicht**: Ist verantwortlich f\xfcr anwendungsinterne Aufgaben, die nicht der Kernlogik zuzuordnen\\nsind. Hierzu geh\xf6ren etwa die Ausf\xfchrung von geplanten Aufgaben, Transaktionssteuerung oder auch das\\nZusammenf\xfchren mehrerer Teile der Kernlogik zu einem Workflow.\\n3. **Adapterschicht**: Handhabt jegliche Interaktion der Anwendung mit der Au\xdfenwelt, wie etwa die Bereitstellung von\\nAPI-Endpunkten, Durchf\xfchrung von Datenbankzugriffen oder die Kommunikation mit anderen Schnittstellen.\\n\\nDie Dom\xe4nenschicht k\xf6nnen wir dabei noch weiter in zwei Teilschichten zerlegen: Modelle (innen) und Logik (au\xdfen).\\nAu\xdferdem kann die Adapterschicht aus mehreren, voneinander unabh\xe4ngigen, Adaptern bestehen (n\xe4mlich ein Adapter je\\nAnlass). Das Modell l\xe4sst sich also folgenderma\xdfen visualisieren:\\n\\n<figure style={{textAlign: \'center\'}}>\\n    <img src={onionLayers} alt=\\"missing\\" height={500}/>\\n    <figcaption>Zwiebelmodell: Schichten</figcaption>\\n</figure>\\n\\nDie Zwiebelarchitektur liefert eine Reihe von Vorteilen, etwa:\\n\\n- **Dom\xe4nenzentriertes Design**: Die Kerngesch\xe4ftslogik wird gegen\xfcber von Infrastrukturangelegenheiten klar in den\\nFokus gesetzt.\\n- **Testbarkeit**: Die Kerngesch\xe4ftslogik ist isoliert und kann dadurch mittels Unittests losgel\xf6st von jeglichen\\nAbh\xe4ngigkeiten getestet werden. Selbiges trifft auch auf die anderen Schichten zu.\\n- **Flexibilit\xe4t**: \xc4nderungen an externen Technologien oder Schnittstellen beschr\xe4nken sich auf die Adapterschicht\\nund wirken sich minimal (im besten Fall gar nicht) auf die Kerngesch\xe4ftslogik aus.\\n- **Wartbarkeit**: Die Schichten kommunizieren \xfcber wohldefinierte Schnittstellen und erm\xf6glichen es daher, bestimmte\\nKomponenten zu aktualisieren oder auszutauschen, ohne den Rest der Anwendung zu beeintr\xe4chtigen.\\n- **Klare Projektstruktur**: Die schichtweise Struktur l\xe4sst sich intuitiv auf die Organisation des Projekts \xfcbertragen.\\n\\nMit diesem Verst\xe4ndnis k\xf6nnen wir nun in die Umsetzung unseres Beispielprojekts starten.\\n\\n## Projektsetup\\n\\nWir starten mit einem neu initialisierten [Spring Boot](https://spring.io/projects/spring-boot) Projekt basierend auf\\n[Java 21](https://openjdk.org/projects/jdk/21), welches\\nwir mit [Maven](https://maven.apache.org/) (via [Maven Wrapper](https://maven.apache.org/wrapper)) verwalten.\\nDar\xfcber hinaus verwenden wir [Prettier Java](https://github.com/jhipster/prettier-java) f\xfcr eine einheitliche Formatierung,\\n[Renovate](https://www.mend.io/renovate) f\xfcr (semi-)automatisierte\\nDependency-Updates, sowie [GitHub Actions](https://github.com/features/actions) f\xfcr automatisierte CI-Builds.\\nDamit sieht unsere Anwendung zum Start folgenderma\xdfen aus:\\n\\n<figure style={{textAlign: \'center\'}}>\\n    <img src={folderStructureInitializedApplication} alt=\\"missing\\"/>\\n    <figcaption>Initialisierte Anwendung</figcaption>\\n</figure>\\n\\nDa wir zu diesem Zeitpunkt keinerlei Anwendungskonfiguration haben, ist die Datei `application.properties` leer und\\nunsere Einstiegsklasse startet bisher lediglich die Anwendung:\\n\\n```java\\n@SpringBootApplication\\nclass HexagonalToDoListApplication {\\n\\n    public static void main(String[] args) {\\n        SpringApplication.run(HexagonalToDoListApplication.class, args);\\n    }\\n}\\n```\\n\\nEtwas interessanter ist unsere Mavenkonfiguration `pom.xml`. Hier binden wir schon einige Abh\xe4ngigkeiten ein, die wir im\\nLaufe der Entwicklung verwenden wollen (die Abh\xe4ngigkeit `spring-boot-starter-data-mongodb` lassen wir hier noch\\nauskommentiert, da ansonsten die Anwendung ohne zus\xe4tzliche Konfiguration nicht starten w\xfcrde) und konfigurieren\\nPrettier. Die vollst\xe4ndige POM sowie das gesamte Projekt k\xf6nnt ihr auf\\n[GitHub](https://github.com/ricardo-schnur/blog-post-hexagonal-architecture/tree/post1) finden.\\n\\n## Geplante Paketstruktur\\n\\nWir orientieren uns hier an dem eingangs dargestellten Zwiebelmodell.\\nDieses Modell k\xf6nnen wir in unserem Java Code exakt in eine Paketstruktur \xfcbersetzen. Gehen wir davon aus, dass unsere\\nAnwendung im Basispaket `base` (f\xfcr unsere konkrete Anwendung ersetze `base` durch `de.colenet.hexagonal.todo.list`)\\nliegt, so kann eine Paketstruktur folgenderma\xdfen aussehen:\\n\\n<figure style={{textAlign: \'center\'}}>\\n    <img src={onionPackages} alt=\\"missing\\" height={500}/>\\n    <figcaption>Zwiebelmodell: Pakete</figcaption>\\n</figure>\\n\\nZur Erinnerung: F\xfcr die Schichten der Zwiebel gilt hierbei, dass Zugriffe nur von au\xdfen nach innen gerichtet erlaubt\\nsind. Dabei d\xfcrfen aber Schichten \xfcbersprungen werden.\\n\\n<figure style={{textAlign: \'center\'}}>\\n    <img src={onionCallHierarchy} alt=\\"missing\\" height={500}/>\\n    <figcaption>Zwiebelmodell: Aufrufe</figcaption>\\n</figure>\\n\\nInsbesondere ist es verschiedenen Adaptern **nicht** erlaubt, sich gegenseitig aufzurufen, auch wenn sie in derselben\\nSchicht dargestellt sind.\\n\\nGenau diese Struktur und Zugriffsrechte wollen wir in unserem Projekt *automatisiert* sicherstellen. Dazu schreiben wir\\nim n\xe4chsten Abschnitt einen *Architektur-Unittest*, der, wie alle anderen Unittests, bei jedem CI-Build ausgef\xfchrt wird\\nund den Build bei einer Verletzung unserer Regeln fehlschlagen l\xe4sst.\\n\\n## Architektur-Unittests\\n\\nHierzu verwenden wir [ArchUnit](https://www.archunit.org/), eine Java Bibliothek, die sich selbst beschreibt als:\\n*ArchUnit is a free, simple and extensible library for checking the architecture of your Java code using any plain Java\\nunit test framework.*\\nKonkret bedeutet das f\xfcr uns, dass ArchUnit es uns erlaubt, normalen Java-Testcode zu schreiben und diese Tests dann\\nmit JUnit auszuf\xfchren. Eine simple Testklasse muss dazu einzig mit `@AnalyzeClasses` annotiert werden. Au\xdferdem m\xfcssen\\nTestf\xe4lle mit der Annotation `@ArchTest` gekennzeichnet werden. F\xfcr mehr Details verweise ich gerne auf die\\nhervorragende [Dokumentation von ArchUnit](https://www.archunit.org/userguide/html/000_Index.html).\\n\\nUnsere Testklasse wird damit folgenderma\xdfen aussehen:\\n\\n```java\\n@AnalyzeClasses(packages = \\"base\\", importOptions = ImportOption.DoNotIncludeTests.class)\\nclass HexagonalArchitectureTest {\\n\\n    @ArchTest\\n    static final ArchRule onionArchitectureIsRespected = ... // TODO\\n```\\n\\nAuff\xe4llig ist hierbei eventuell die Konfiguration `importOptions = ImportOption.DoNotIncludeTests.class`,\\ndie Testklassen von unserem Architekturtest ausschlie\xdft. Dazu habe ich mich entschieden, um beim Testen etwas mehr\\nFlexibilit\xe4t zu bewahren. Ihr k\xf6nnt diese Option in eurer Anwendung nat\xfcrlich au\xdfen vor lassen, um noch strikter zu\\nsein.\\n\\nUm unseren Test zu vervollst\xe4ndigen, verwenden wir die von ArchUnit von Haus aus\\nbereitgestellte [Onion Architecture Regel](https://www.archunit.org/userguide/html/000_Index.html#_architectures).\\n\\n```java\\n@ArchTest\\nstatic final ArchRule onionArchitectureIsRespected = Architectures\\n        .onionArchitecture()\\n        .domainModels(\\"base.domain.model\\")\\n        .domainServices(\\"base.domain.service\\")\\n        .applicationServices(\\"base.application\\")\\n        .adapter(\\"adapter1\\",\\"base.adapter.adapter1\\")\\n        .adapter(\\"adapter2\\",\\"base.adapter.adapter2\\")\\n        // ... more adapters\\n        .ensureAllClassesAreContainedInArchitectureIgnoring(\\"base\\");\\n```\\n\\nWir ignorieren der Einfachheit halber alle Klassen, die direkt in unserem Basispaket liegen, da sich dort aus\\ntechnischen Gr\xfcnden unsere mit `@SpringBootApplication` annotierte Einstiegsklasse befindet. In einer Produktivanwendung\\nk\xf6nnten wir hier mittels eines `DescribedPredicate` genauer sein und nur diese eine Einstiegsklasse vom\\nTest ausschlie\xdfen.\\n\\nF\xfcr unseren Fall m\xfcssen wir nun nat\xfcrlich das korrekte Basispaket verwenden und konkrete Adapter definieren.\\nHier wollen wir f\xfcr den Moment mit den Adaptern `cache` und `rest` starten. Au\xdferdem setzen wir tempor\xe4r die\\nOption `withOptionalLayers(true)` um leere Schichten zu erlauben.\\n\\n```java\\n@AnalyzeClasses(packages = HexagonalArchitectureTest.BASE_PACKAGE, importOptions = ImportOption.DoNotIncludeTests.class)\\nclass HexagonalArchitectureTest {\\n\\n    static final String BASE_PACKAGE = \\"de.colenet.hexagonal.todo.list\\";\\n\\n    @ArchTest\\n    static final ArchRule onionArchitectureIsRespected = Architectures\\n            .onionArchitecture()\\n            .domainModels(getPackageIdentifier(\\"domain.model\\"))\\n            .domainServices(getPackageIdentifier(\\"domain.service\\"))\\n            .applicationServices(getPackageIdentifier(\\"application\\"))\\n            .adapter(\\"cache\\", getAdapterIdentifier(\\"cache\\"))\\n            .adapter(\\"rest\\", getAdapterIdentifier(\\"rest\\"))\\n            .withOptionalLayers(true) // TODO Remove this as soon as our layers are filled\\n            .ensureAllClassesAreContainedInArchitectureIgnoring(BASE_PACKAGE);\\n\\n    private static String getAdapterIdentifier(String name) {\\n        return getPackageIdentifier(\\"adapter.\\" + name);\\n    }\\n\\n    private static String getPackageIdentifier(String subpackage) {\\n        return BASE_PACKAGE + \\".\\" + subpackage + \\"..\\";\\n    }\\n}\\n```\\n\\n## Ausblick\\n\\nIm n\xe4chsten Teil dieser Serie f\xfcllen wir unsere Anwendung mit erster Funktionalit\xe4t.\\nDazu werden wir einen Service aufsetzen, der es uns erlaubt, Tasks anzulegen, auszulesen und als abgeschlossen zu markieren.\\nDie Daten werden wir f\xfcr den Anfang in einem In-Memory Cache halten.\\nIn einem sp\xe4teren Beitrag werden wir diesen dann durch eine echte Datenbank ersetzen."}]}')}}]);